(()=>{"use strict";var e,n={4147:(e,n,t)=>{var r={};t.r(r),t.d(r,{blockType:()=>jt,controlInstr:()=>Ct,elem:()=>Rt,exportNode:()=>Xt,exportedFunc:()=>Gt,exportedGlobal:()=>Qt,exportedMemory:()=>Ht,exportedTable:()=>Zt,float32:()=>_t,float32NumericInstr:()=>Kt,float64:()=>gt,float64NumericInstr:()=>Pt,func:()=>Dt,funcSig:()=>Nt,funcType:()=>It,funcTypeRef:()=>Lt,functionIndexList:()=>Ot,globalNode:()=>Wt,identifier:()=>vt,ifInstr:()=>Mt,int32:()=>mt,int32NumericInstr:()=>At,int64:()=>ht,int64NumericInstr:()=>Vt,limits:()=>yt,localVar:()=>Et,memory:()=>kt,memoryInstr:()=>qt,mod:()=>bt,mutValueType:()=>xt,paramType:()=>Tt,refType:()=>wt,syntacticPlaceholder:()=>pt,tableType:()=>Bt,tableWithElemList:()=>Ut,tableWithType:()=>zt,typedef:()=>Ft,uint32:()=>ft,valueType:()=>$t,variableInstr:()=>St});var i={};t.r(i);var s={};t.r(s);var a={};t.r(a);var o={};t.r(o);var l={};t.r(l);var c={};t.r(c);var u={};t.r(u);var d={};t.r(d);var p={};t.r(p);var f={};t.r(f);var m=t(1085),h=t(3144),_=t(1841),g=t.n(_);g().define("ace/theme/iceberg",((e,n)=>{n.isDark=!0,n.cssClass="ace-iceberg"})),g().config.setModuleUrl("ace/mode/ocaml",t(8));var y=t(4569),k=t(4041),b=t(683),v=t(5923),$=t(3616),x=t(8225);var T=t(6004),w=t(2320),E=t(8045),I=t(1452),F=t(6248),L=t(8737),N=t(406);function j(e){return e<<1|1}function M(e,n){return n>>1}function C(e,n){return(0,e.exports.__float_get__)(n)}function S(e,n){return!!n}function A(e,n){return(t=(e,n)=>n,(e,n)=>{const r=e.exports.__list_tail__,i=e.exports.__list_head__,s=e=>e>0?[i(e),...s(r(e))]:[];return s(n).map((e=>t(0,e)))})(e,n);var t}const V=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];function K(e,n){let t="";if(e<0)return"";do{t=V[15&e]+t,e>>=4}while(e);return t.padStart(n,"0")}function P(e){return e.slice().sort(((e,n)=>e.id-n.id)).reduce(((e,n)=>e[0]?.id===n.id?e:[n,...e]),[]).reverse()}function q(e,n){let t=0,r=0,i=[];for(;t<e.length;){const s=e[t],a=n[r];!a||s.id<a.id?(i.push(s),t++):s.id===a.id?(t++,r++):s.id>a.id&&r++}return i}function D(e){switch(e.kind){case"Int":case"Float":case"Bool":return[];case"TypeParameter":return[e];case"List":return D(e.elementType);case"Function":return[...D(e.paramType),...D(e.returnType)]}}function B(e){return P(D(e))}function z(e){return q(B(e.type),P(e.variables))}function O(e){const n=e.parent();return n?[...O(n.env),...z(n.value)]:[]}function W(e){return P(O(e))}function R(e,n){return{kind:"TypeScheme",type:e,variables:q(B(e),W(n))}}const U={Bool:0,Int:0,Float:0,TypeParameter:0,List:10,Function:20};function G(e,n,t){const r=H(n,t);return U[n.kind]<=U[e.kind]?r:`(${r})`}function H(e,n){switch(e.kind){case"Int":return"int";case"Float":return"float";case"Bool":return"bool";case"TypeParameter":return function(e){let n=[String.fromCharCode(97+e%26)];for(;e=~~(e/26);){const t=e%26;n.unshift(String.fromCodePoint(96+t))}return"'"+n.join("")}(n.idMap(e.id));case"List":return`${G(e,e.elementType,n)} list`;case"Function":return`${function(e,n,t){const r=H(n,t);return U[n.kind]<U[e.kind]?r:`(${r})`}(e,e.paramType,n)} -> ${G(e,e.returnType,n)}`}}function Z(e,n=Number.MAX_SAFE_INTEGER){switch(e.kind){case"Int":case"Float":case"Bool":return n;case"TypeParameter":return e.id<n?e.id:n;case"List":return Z(e.elementType,n);case"Function":return Math.min(Z(e.paramType,n),Z(e.returnType,n))}}function Q(e){const n=(t,r)=>{const i=t.kind,s=i[0].toLowerCase()+i.slice(1),a=e[s];if("function"!=typeof a)throw new Error("invalid kind");return a(t,r,n)};return n}function X(e){return"object"==typeof e&&"string"==typeof e.kind}function J(e){return{forEachChild:(n,t)=>{for(const r of e){const e=n[r];e&&(Array.isArray(e)?e.forEach((e=>{X(e)&&t(e)})):X(e)&&t(e))}},visitEachChild:(n,t)=>{const r={...n};for(const i of e){const e=n[i];if(e)if(Array.isArray(e)){const n=e.reduce(((e,n)=>{if(!X(n))return[...e,n];const r=t(n);return null===r?e:r?Array.isArray(r)?[...e,...r]:[...e,r]:[...e,n]}),[]);r[i]=n}else if(X(e)){const n=t(e);n&&(r[i]=n)}}return r}}}function Y(e){if(!e.ok)throw new Error(e.value.message);return e.value}function ee(...e){return n=>{const t=[];for(const n of e){if(!n.ok)return n;t.push(n.value)}return n(...t)}}function ne(e){const n=[];for(const t of e){if(!t.ok)return t;n.push(t.value)}return te(n)}function te(e){const n={ok:!0,value:e,unwrap:()=>Y(n),map:n=>te(n(e)),tap:n=>(n(e),te(e)),error:()=>n,mapValue:n=>n(e)};return n}function re(e){const n={ok:!1,value:e,unwrap:()=>Y(n),map:()=>n,tap:()=>n,error:n=>re(n(e)),mapValue:()=>n};return n}function ie(){return{mapValue:ee,ok:e=>te(e),error:e=>re(e)}}const se=(...e)=>n=>{const t=n.pos;let r=re({confirmed:!1,message:"",occurence:{loc:{pos:t,end:t+1}}});for(const t of e.slice().reverse()){if(r=t(n),!r.ok&&r.value.confirmed)return r;if(r.ok)return r}return re({message:"Unexpected expression.",confirmed:!1,occurence:{loc:{pos:t,end:n.pos===t?t+1:n.pos}}})},ae=e=>n=>e()(n),oe=(...e)=>n=>t=>{const r=[];let i=0;for(const n of e){const e=n(t);if(!e.ok)return re({...e.value,confirmed:0!==i});r.push(e.value),i++}return te(n(...r,t))};let le=0;function ce(){return K(++le,6)}function ue(...e){if(0===e.length)return{_nodeId:ce()};const[n,...t]=e;if(!t.length)return{loc:n.loc,_nodeId:ce()};const r=t[t.length-1];return{loc:{pos:n.loc?.pos,end:r.loc?.end},_nodeId:ce()}}const de=e=>(...n)=>t=>r=>{const i=e(r);if(!i.ok)return i;const s=e=>{const i=[];let a=0;for(const t of n){const n=t(r);if(!n.ok)return 0===a?te(e):re({...n.value,message:"Missing operand.",confirmed:!1});i.push(n.value),a++}return s(t(e,...i))};return s(i.value)},pe=e=>(...n)=>t=>r=>{const i=e(r);if(!i.ok)return i;const s=e=>{const i=[];let a=0;for(const t of n){const n=t(r);if(!n.ok)return 0===a?te(e):re({...n.value,message:"Missing operand.",confirmed:!1});i.push(n.value),a++}const o=i.slice(0,i.length-1),l=i[i.length-1];return te(t(e,...o,s(l).value))};return s(i.value)};class fe{input;_pos=0;constructor(e){this.input=e}_head(e=0){const n=this._leadingTrivia();return this.input.substr(this._pos+n+e)}_leadingTrivia(){let e=0;for(;;){const n=this.leadingWhitespace(this._pos+e),t=this.leadingComment(this._pos+e+n);if(0===n&&0===t)break;e+=n+t}return e}hasNext(e=0){return this.pos+this._leadingTrivia()+e<this.input.length}slice(e){return this._head().slice(0,e)}startsWith(e,n=0){return this._head(n).startsWith(e)}match(e,n=0){return this._head(n).match(e)}leadingWhitespace(e){let n=0;for(;;n++){const t=this.input[e+n];if(" "!==t&&"\t"!==t&&"\r"!==t&&"\n"!==t)break}return n}leadingComment(e){return 0}consume(e){const n=this._leadingTrivia(),t={pos:this._pos+n,end:this._pos+n+e};return this._pos+=n+e,t}get pos(){return this._pos}back(e){return this._pos=e,e}}class me extends fe{leadingComment(e){if(!this.input.slice(e).startsWith("(*"))return 0;let n=1,t=2;for(;n>0&&e+t<this.input.length;)"*)"===this.input.substr(e+t,2)?(t+=2,n--):"(*"===this.input.substr(e+t,2)?(t+=2,n++):++t;return t}}const he=["if","then","else","let","in","fun","rec","true","false","match","with"],_e=e=>n=>n.startsWith(e)?te({tokenKind:"Symbol",symbol:e,loc:n.consume(e.length)}):re({confirmed:!1,message:`'${e}' expected.`,occurence:{loc:{pos:n.pos,end:n.pos+1}}}),ge=e=>n=>n.startsWith(e)&&n.match(/^($|[^a-zA-Z0-9\$_])/,e.length)?te({tokenKind:"Keyword",keyword:e,loc:n.consume(e.length)}):re({confirmed:!1,message:`'${e}' expected.`,occurence:{loc:{pos:n.pos,end:n.pos+1}}}),ye=e=>n=>{const t=[];for(;;){const r=e(n);if(!r.ok)break;t.push(r.value)}return te({values:t,loc:t.length?ue(...t).loc:{pos:n.pos,end:n.pos}})},ke=se(ae((()=>Fe)),ae((()=>$e)),ae((()=>xe)),ae((()=>ve)),ae((()=>be))),be=oe(ge("let"),se(oe(ae((()=>ze)),ye(ae((()=>ze))),_e("="),ae((()=>ke)),ge("in"),ae((()=>ke)))(((e,n,t,r,i,s)=>({kind:"LetExpression",identifier:e,binding:n.values.slice().reverse().reduce(((e,n)=>({kind:"FunctionDefinition",param:n,body:e,...ue(r)})),r),exp:s,...ue(e,n,t,r,i,s)}))),oe(ge("rec"),ae((()=>ze)),se(oe(_e("="),ae((()=>ve)))(((e,n)=>n)),oe(ae((()=>ze)),ye(ae((()=>ze))),_e("="),ae((()=>ke)))(((e,n,t,r)=>({kind:"FunctionDefinition",param:e,body:n.values.slice().reverse().reduce(((e,n)=>({kind:"FunctionDefinition",param:n,body:e,...ue(r)})),r),...ue(e,n,t,r)})))),ge("in"),ae((()=>ke)))(((e,n,t,r,i)=>({kind:"LetRecExpression",identifier:n,binding:t,exp:i,...ue(e,n,t,r,i)})))))(((e,n)=>({...n,...ue(e,n)}))),ve=oe(ge("fun"),ae((()=>ze)),_e("->"),ae((()=>ke)))(((e,n,t,r)=>({kind:"FunctionDefinition",param:n,body:r,...ue(e,n,t,r)}))),$e=oe(ge("if"),ae((()=>ke)),ge("then"),ae((()=>ke)),ge("else"),ae((()=>ke)))(((e,n,t,r,i,s)=>({kind:"IfExpression",cond:n,then:r,else:s,...ue(e,n,t,r,i,s)}))),xe=oe(ge("match"),ae((()=>ke)),ge("with"),ae((()=>Te)))(((e,n,t,r)=>({kind:"MatchExpression",exp:n,matchClause:r,...ue(e,n,t,r)}))),Te=pe(ae((()=>we)))(_e("|"),ae((()=>we)))(((e,n,t)=>({kind:"MatchOrClause",patternMatch:e,or:t,...ue(e,n,t)}))),we=oe(ae((()=>Ee)),_e("->"),ae((()=>ke)))(((e,n,t)=>({kind:"PatternMatchClause",pattern:e,exp:t,...ue(e,n,t)}))),Ee=pe(ae((()=>Ie)))(_e("::"),ae((()=>Ie)))(((e,n,t)=>({kind:"ListConsPattern",head:e,tail:t,...ue(e,n,t)}))),Ie=se(oe(ae((()=>ze)))((e=>({kind:"IdPattern",identifier:e,...ue(e)}))),oe(_e("["),_e("]"))(((e,n)=>({kind:"EmptyListPattern",...ue(e,n)}))),oe(_e("_"))((e=>({kind:"WildcardPattern",...ue(e)})))),Fe=pe(ae((()=>Le)))(_e("||"),se(ae((()=>Le)),ae((()=>$e)),ae((()=>xe)),ae((()=>ve)),ae((()=>be))))(((e,n,t)=>({kind:"BinaryExpression",op:{kind:"Or",token:n},left:e,right:t,...ue(e,n,t)}))),Le=pe(ae((()=>Ne)))(_e("&&"),se(ae((()=>Ne)),ae((()=>$e)),ae((()=>xe)),ae((()=>ve)),ae((()=>be))))(((e,n,t)=>({kind:"BinaryExpression",op:{kind:"And",token:n},left:e,right:t,...ue(e,n,t)}))),Ne=de(ae((()=>je)))(se(_e("<"),_e(">"),_e("<="),_e(">="),_e("="),_e("<>"),_e("=="),_e("!=")),se(ae((()=>je)),ae((()=>$e)),ae((()=>xe)),ae((()=>ve)),ae((()=>be))))(((e,n,t)=>({kind:"BinaryExpression",op:{kind:"<"===n.symbol?"LessThan":">"===n.symbol?"GreaterThan":"<="===n.symbol?"LessEqualThan":">="===n.symbol?"GreaterEqualThan":"="===n.symbol?"Equal":"<>"===n.symbol?"NotEqual":"=="===n.symbol?"PEqual":"!="===n.symbol?"PNotEqual":void 0,token:n},left:e,right:t,...ue(e,n,t)}))),je=pe(ae((()=>Me)))(_e("::"),se(ae((()=>Me)),ae((()=>$e)),ae((()=>xe)),ae((()=>ve)),ae((()=>be))))(((e,n,t)=>({kind:"ListConstructor",head:e,tail:t,...ue(e,n,t)}))),Me=de(ae((()=>Ce)))(se(_e("+"),_e("-"),_e("+."),_e("-.")),se(ae((()=>Ce)),ae((()=>$e)),ae((()=>xe)),ae((()=>ve)),ae((()=>be))))(((e,n,t)=>({kind:"BinaryExpression",op:"+"===n.symbol?{kind:"Add",token:n}:"+."===n.symbol?{kind:"FAdd",token:n}:"-"===n.symbol?{kind:"Sub",token:n}:"-."===n.symbol?{kind:"FSub",token:n}:null,left:e,right:t,...ue(e,n,t)}))),Ce=de(ae((()=>Se)))(se(_e("*"),_e("*."),_e("/"),_e("/.")),se(ae((()=>Se)),ae((()=>$e)),ae((()=>xe)),ae((()=>ve)),ae((()=>be))))(((e,n,t)=>({kind:"BinaryExpression",op:{kind:"*"===n.symbol?"Multiply":"*."===n.symbol?"FMultiply":"/"===n.symbol?"Div":"/."===n.symbol?"FDiv":null,token:n},left:e,right:t,...ue(e,n,t)}))),Se=se(ae((()=>Ae)),oe(se(_e("-"),_e("-.")),ae((()=>Ae)))(((e,n)=>({kind:"UnaryExpression",op:"-"===e.symbol?{kind:"Minus",token:e}:{kind:"FMinus",token:e},exp:n,...ue(e,n)})))),Ae=de(ae((()=>Ve)))(ae((()=>Ve)))(((e,n)=>({kind:"FunctionApplication",callee:e,argument:n,...ue(e,n)}))),Ve=se(ae((()=>ze)),ae((()=>Be)),ae((()=>De)),ae((()=>qe)),ae((()=>Pe)),ae((()=>Ke))),Ke=oe(_e("("),ae((()=>ke)),_e(")"))(((e,n,t)=>({...n,...ue(e,n,t)}))),Pe=oe(_e("["),_e("]"))(((e,n)=>({kind:"EmptyList",...ue(e,n)}))),qe=se(oe(ge("true"))((e=>({kind:"BoolLiteral",value:!0,...ue(e)}))),oe(ge("false"))((e=>({kind:"BoolLiteral",value:!1,...ue(e)})))),De=oe((e=>{const n=e.match(/^(\d+\.\d*)/);return n?te({tokenKind:"Decimal",value:parseFloat(n[1]),loc:e.consume(n[1].length)}):re({confirmed:!1,message:"Floating number expected.",occurence:{loc:{pos:e.pos,end:e.pos+1}}})}))((e=>({kind:"FloatLiteral",value:e.value,...ue(e)}))),Be=oe((e=>{const n=e.match(/^(\d+)/);return n?te({tokenKind:"Integer",value:parseInt(n[1],10),loc:e.consume(n[1].length)}):re({confirmed:!1,message:"Integer expected.",occurence:{loc:{pos:e.pos,end:e.pos+1}}})}))((e=>({kind:"IntLiteral",value:e.value,...ue(e)}))),ze=oe((e=>{const n=e.match(/^([a-zA-Z_][a-zA-Z0-9_']*)/);if(!n)return re({confirmed:!1,message:"Identifier expected.",occurence:{loc:{pos:e.pos,end:e.pos+1}}});const t=he.find((e=>e===n[1]));return t?re({confirmed:!0,message:`'${t}' is not allowed as an identifier name.`,occurence:{loc:{pos:e.pos,end:e.pos+t.length}}}):te({tokenKind:"Variable",name:n[1],loc:e.consume(n[1].length)})}))((e=>({kind:"Identifier",name:e.name,...ue(e)})));function Oe(e){return ke(new me(e))}function We(e,n){let t=0,r=0;for(let i=0;i<e.length;i++){const s=e[i];if(t===n.line&&r===n.character)return i;"\n"===s?(r=0,t++):r++}return e.length}class Re{idx=0;gen(e){return{kind:"TypeParameter",id:this.idx++,referencedFrom:e}}}function Ue(){const e={kind:"TypeEnvironment",get(){},parent(){},map:()=>e};return e}function Ge(e,n,t){const r={kind:"TypeEnvironment",get:r=>e.name===r.name?n:t.get(r),parent:()=>({value:n,env:t}),map(t){const{env:i}=r.parent(),s=i.map(t),a=t(n);return Ge(e,a,s)}};return r}const{ok:He,error:Ze}=ie(),Qe={ok:(e,n=[])=>He({expressionType:e,substitutions:n}),error:Ze},Xe=e=>Qe.ok({kind:"Int",referencedFrom:e}),Je=e=>Qe.ok({kind:"Float",referencedFrom:e}),Ye=e=>Qe.ok({kind:"Bool",referencedFrom:e}),en=(e,n)=>Qe.ok({kind:"List",elementType:n.generator.gen(e),referencedFrom:e});function nn(e,...n){return n.reduce(((e,n)=>function(e,n){switch(e.kind){case"Int":case"Float":case"Bool":return e;case"TypeParameter":return e.id===n.from.id?{...n.to,referencedFrom:e.referencedFrom}:e;case"Function":return{kind:"Function",paramType:nn(e.paramType,n),returnType:nn(e.returnType,n),referencedFrom:e.referencedFrom};case"List":return{kind:"List",elementType:nn(e.elementType,n),referencedFrom:e.referencedFrom}}}(e,n)),e)}function tn(e,...n){return e.map((e=>function(e,...n){return n.reduce(((n,t)=>n.variables.some((e=>e.id===t.from.id))?e:{...e,type:nn(e.type,t)}),e)}(e,...n)))}function rn(...e){return e.reduce(((e,{substitutions:n})=>[...e,...n.map((({from:e,to:n})=>({lhs:e,rhs:n})))]),[])}const sn=(e,n)=>{const t=n.env.get(e);if(!t)return Qe.error({message:`No identifier ${e.name}`,occurence:e});const r=t.variables.map((t=>({from:t,to:n.generator.gen(e)})));return Qe.ok({...nn(t.type,...r),referencedFrom:e})};function an(e,n){switch(e.kind){case"Int":case"Float":case"Bool":return e.kind===n.kind;case"Function":return"Function"===n.kind&&an(e.paramType,n.paramType)&&an(e.returnType,n.returnType);case"List":return"List"===n.kind&&an(e.elementType,n.elementType);case"TypeParameter":return"TypeParameter"===n.kind&&e.id===n.id}}function on(e){return{kind:"TypeScheme",type:e,variables:[]}}function ln(e,n,t,r,i=[],s=[]){if("WildcardPattern"===e.kind)return te({typeEnv:t,equations:s});if("EmptyListPattern"===e.kind){const i=r.gen(e);return te({typeEnv:t,equations:[...s,{lhs:n,rhs:{kind:"List",elementType:i,referencedFrom:e}}]})}if("IdPattern"===e.kind)return i.some((n=>n===e.identifier.name))?re({message:`Duplicated identifier, '${e.identifier.name}'.`,occurence:e.identifier}):te({typeEnv:Ge(e.identifier,on(n),t),equations:s});if("ListConsPattern"===e.kind){if("IdPattern"===e.head.kind){const a=e.head.identifier.name;if(i.some((e=>e===a)))return re({message:`Duplicated identifier, '${a}'.`,occurence:e.head.identifier});const o=r.gen(e.head);return ln(e.tail,n,Ge(e.head.identifier,on(o),t),r,[...i,a],[...s,{lhs:n,rhs:{kind:"List",elementType:o,referencedFrom:e}}])}return ln(e.tail,n,t,r,i,s)}throw new Error(`invalid node kind: ${e.kind}`)}const{ok:cn,error:un}=ie();function dn(e){if(0===e.length)return cn([]);const[n,...t]=e;if(an(n.lhs,n.rhs))return dn(t);if("Function"===n.lhs.kind&&"Function"===n.rhs.kind)return dn([...t,{lhs:n.lhs.paramType,rhs:n.rhs.paramType},{lhs:n.lhs.returnType,rhs:n.rhs.returnType}]);if("List"===n.lhs.kind&&"List"===n.rhs.kind)return dn([...t,{lhs:n.lhs.elementType,rhs:n.rhs.elementType}]);let r,i;if("TypeParameter"===n.lhs.kind&&(r=n.lhs,i=n.rhs),"TypeParameter"===n.rhs.kind&&(r=n.rhs,i=n.lhs),null!=r&&null!=i){if(function(e){switch(e.kind){case"TypeScheme":return z(e);case"TypeEnvironment":return W(e);default:return B(e)}}(i).some((e=>e.id===r?.id)))return un({message:"This equation does not have solution.",occurence:r.referencedFrom});const n={from:r,to:i};return dn(function(e,n){return e.map((e=>({lhs:nn(e.lhs,n),rhs:nn(e.rhs,n)})))}(e,n)).map((e=>function(e,n){return[{from:n.from,to:e.reduce(((e,n)=>nn(e,n)),n.to)},...e]}(e,n)))}return un({message:"This equation does not have solution.",occurence:n.lhs.referencedFrom,messageWithTypes:e=>`This expression type is "${e(n.lhs)}" but the expected type is "${e(n.rhs)}".`})}const pn=(e,n,t)=>ee(t(e.head,n),t(e.tail,n))(((n,t)=>dn([...rn(n,t),{lhs:t.expressionType,rhs:{kind:"List",elementType:n.expressionType,referencedFrom:e}}]).mapValue((e=>Qe.ok(nn(t.expressionType,...e),e))))),fn=(e,n,t)=>{switch(e.op.kind){case"Minus":return t(e.exp,n).mapValue((n=>dn([...rn(n),{lhs:n.expressionType,rhs:{kind:"Int",referencedFrom:e}}]).mapValue((n=>Qe.ok({kind:"Int",referencedFrom:e},n)))));case"FMinus":return t(e.exp,n).mapValue((n=>dn([...rn(n),{lhs:n.expressionType,rhs:{kind:"Float",referencedFrom:e}}]).mapValue((n=>Qe.ok({kind:"Float",referencedFrom:e},n)))));default:throw new Error(`invalid operation ${e.op.kind}`)}},mn={Add:"Int",FAdd:"Float",Sub:"Int",FSub:"Float",Multiply:"Int",FMultiply:"Float",Div:"Int",FDiv:"Float",Or:"Bool",And:"Bool",LessThan:"Bool",LessEqualThan:"Bool",GreaterThan:"Bool",GreaterEqualThan:"Bool",Equal:"Bool",NotEqual:"Bool",PEqual:"Bool",PNotEqual:"Bool"},hn={Add:"Int",FAdd:"Float",Sub:"Int",FSub:"Float",Multiply:"Int",FMultiply:"Float",Div:"Int",FDiv:"Float",Or:"Bool",And:"Bool"};function _n(e,n,t){return"LessThan"===e.op.kind||"LessEqualThan"===e.op.kind||"GreaterThan"===e.op.kind||"GreaterEqualThan"===e.op.kind||"Equal"===e.op.kind||"NotEqual"===e.op.kind||"PEqual"===e.op.kind||"PNotEqual"===e.op.kind?[{lhs:n.expressionType,rhs:t.expressionType}]:[{lhs:n.expressionType,rhs:{kind:hn[e.op.kind],referencedFrom:e.left}},{lhs:t.expressionType,rhs:{kind:hn[e.op.kind],referencedFrom:e.right}}]}const gn=(e,n,t)=>ee(t(e.left,n),t(e.right,n))(((n,t)=>dn([...rn(n,t),..._n(e,n,t)]).mapValue((n=>Qe.ok({kind:mn[e.op.kind],referencedFrom:e},n))))),yn=(e,n,t)=>{const r=n.generator.gen(e.param),i=Ge(e.param,on(r),n.env);return t(e.body,{...n,env:i}).mapValue((n=>Qe.ok(nn({kind:"Function",paramType:r,returnType:n.expressionType,referencedFrom:e},...n.substitutions),n.substitutions)))},kn=(e,n,t)=>ee(t(e.cond,n),t(e.then,n),t(e.else,n))(((n,t,r)=>dn([...rn(n,t,r),{lhs:n.expressionType,rhs:{kind:"Bool",referencedFrom:e.cond}},{lhs:t.expressionType,rhs:r.expressionType}]).mapValue((e=>Qe.ok(nn(t.expressionType,...e),e))))),bn=(e,n,t)=>t(e.exp,n).mapValue((r=>{const i=function(e){const n=(e,t=[])=>"PatternMatchClause"===e.kind?[...t,e]:n(e.or,[...t,e.patternMatch]);return n(e.matchClause)}(e);return ee(...i.map((({pattern:e,exp:i})=>ln(e,r.expressionType,n.env,n.generator).mapValue((({typeEnv:e,equations:r})=>t(i,{...n,env:e}).map((e=>({patternType:e,equations:r}))))))))(((...e)=>{const n=e.map((e=>e.patternType)),t=e.flatMap((e=>e.equations));if(0===n.length)throw new Error("unreachable");const[i,...s]=n,a=s.map((e=>({lhs:i.expressionType,rhs:e.expressionType})));return dn([...rn(r,...n),...t,...a]).mapValue((e=>Qe.ok(nn(i.expressionType,...e),e)))}))})),vn=(e,n,t)=>ee(t(e.binding,n))((r=>{const i=R(r.expressionType,tn(n.env,...r.substitutions)),s=Ge(e.identifier,i,n.env);return t(e.exp,{...n,env:s}).mapValue((e=>dn(rn(r,e)).mapValue((n=>Qe.ok(nn(e.expressionType,...n),n)))))})),$n=(e,n,t)=>{const r=n.generator.gen(e.binding),i=n.generator.gen(e.binding.param),s=Ge(e.binding.param,on(i),Ge(e.identifier,on(r),n.env));return t(e.binding.body,{...n,env:s}).mapValue((s=>dn([...rn(s),{lhs:r,rhs:{kind:"Function",paramType:i,returnType:s.expressionType,referencedFrom:e.binding}}]).mapValue((i=>{const s=R(nn(r,...i),tn(n.env,...i)),a=Ge(e.identifier,s,n.env);return ee(t(e.exp,{...n,env:a}))((e=>dn(rn({substitutions:i},e)).mapValue((n=>Qe.ok(nn(e.expressionType,...n),n)))))}))))},xn=(e,n,t)=>ee(t(e.callee,n),t(e.argument,n))(((t,r)=>{const i=n.generator.gen(e);return dn([...rn(t,r),{lhs:{kind:"Function",paramType:r.expressionType,returnType:i,referencedFrom:e.callee},rhs:t.expressionType}]).mapValue((e=>Qe.ok(nn(i,...e),e)))}));function Tn(e){const n=new Map;return Q(function(e){const n=Object.keys(e),t={};for(const r of n){const n=e[r],i=(e,t,r)=>{const i=n(e,t,r);return i.ok&&e._nodeId&&t.ptMap?.set(e._nodeId,i.value.expressionType),i};t[r]=i}return t}({intLiteral:Xe,floatLiteral:Je,boolLiteral:Ye,emptyList:en,identifier:sn,listConstructor:pn,unaryExpression:fn,binaryExpression:gn,functionDefinition:yn,ifExpression:kn,matchExpression:bn,letExpression:vn,letRecExpression:$n,functionApplication:xn}))(e,{generator:new Re,env:Ue(),ptMap:n}).map((e=>({rootPrimaryType:e,typeValueMap:n})))}function wn(e,n){e.forEach(((e,t)=>{e.id&&n.set(e.id.value,t)}))}function En(e,n){if("Uint32Literal"===n.kind)return te(n.value);const t=e.get(n.value);return null==t?re({message:`Not found "${n.value}"`}):te(t)}function In(e){switch(e.valueKind){case"i32":return{kind:"Int32Type"};case"i64":return{kind:"Int64Type"};case"f32":return{kind:"Float32Type"};case"f64":return{kind:"Float64Type"};default:throw new Error(`Invalid value kind: ${e.valueKind}`)}}function Fn(e){return e.map((e=>In(e.valueType)))}const Ln={block:{code:2},loop:{code:3},if:{code:4},else:{code:5},end:{code:11}},Nn={unreachable:{code:0,args:[]},nop:{code:1,args:[]},br:{code:12,args:["labels"]},br_if:{code:13,args:["labels"]},return:{code:15,args:[]},call:{code:16,args:["funcs"]},call_indirect:{code:17,args:["tables","types"]}},jn={"local.get":{code:32,args:["locals"]},"local.set":{code:33,args:["locals"]},"local.tee":{code:34,args:["locals"]},"global.get":{code:35,args:["globals"]},"global.set":{code:36,args:["globals"]}},Mn={"i32.const":{code:65,args:["SignedInteger"]},"i32.eqz":{code:69,args:[]},"i32.eq":{code:70,args:[]},"i32.ne":{code:71,args:[]},"i32.lt_s":{code:72,args:[]},"i32.lt_u":{code:73,args:[]},"i32.gt_s":{code:74,args:[]},"i32.gt_u":{code:75,args:[]},"i32.le_s":{code:76,args:[]},"i32.le_u":{code:77,args:[]},"i32.ge_s":{code:78,args:[]},"i32.ge_u":{code:79,args:[]},"i32.clz":{code:103,args:[]},"i32.ctz":{code:104,args:[]},"i32.popcnt":{code:105,args:[]},"i32.add":{code:106,args:[]},"i32.sub":{code:107,args:[]},"i32.mul":{code:108,args:[]},"i32.div_s":{code:109,args:[]},"i32.div_u":{code:110,args:[]},"i32.rem_s":{code:111,args:[]},"i32.rem_u":{code:112,args:[]},"i32.and":{code:113,args:[]},"i32.or":{code:114,args:[]},"i32.xor":{code:115,args:[]},"i32.shl":{code:116,args:[]},"i32.shr_s":{code:117,args:[]},"i32.shr_u":{code:118,args:[]},"i32.rotl":{code:119,args:[]},"i32.rotr":{code:120,args:[]}},Cn={"i64.const":{code:66,args:["DoubleSignedInteger"]},"i64.eqz":{code:80,args:[]},"i64.eq":{code:81,args:[]},"i64.ne":{code:82,args:[]},"i64.lt_s":{code:83,args:[]},"i64.lt_u":{code:84,args:[]},"i64.gt_s":{code:85,args:[]},"i64.gt_u":{code:86,args:[]},"i64.le_s":{code:87,args:[]},"i64.le_u":{code:88,args:[]},"i64.ge_s":{code:89,args:[]},"i64.ge_u":{code:90,args:[]},"i64.clz":{code:121,args:[]},"i64.ctz":{code:122,args:[]},"i64.popcnt":{code:123,args:[]},"i64.add":{code:124,args:[]},"i64.sub":{code:125,args:[]},"i64.mul":{code:126,args:[]},"i64.div_s":{code:127,args:[]},"i64.div_u":{code:128,args:[]},"i64.rem_s":{code:129,args:[]},"i64.rem_u":{code:130,args:[]},"i64.and":{code:131,args:[]},"i64.or":{code:132,args:[]},"i64.xor":{code:133,args:[]},"i64.shl":{code:134,args:[]},"i64.shr_s":{code:135,args:[]},"i64.shr_u":{code:136,args:[]},"i64.rotl":{code:137,args:[]},"i64.rotr":{code:138,args:[]}},Sn={"f32.const":{code:67,args:["SignedFloat"]},"f32.eq":{code:91,args:[]},"f32.ne":{code:92,args:[]},"f32.lt":{code:93,args:[]},"f32.gt":{code:94,args:[]},"f32.le":{code:95,args:[]},"f32.ge":{code:96,args:[]},"f32.abs":{code:139,args:[]},"f32.neg":{code:140,args:[]},"f32.ceil":{code:142,args:[]},"f32.floor":{code:141,args:[]},"f32.trunc":{code:143,args:[]},"f32.nearest":{code:144,args:[]},"f32.sqrt":{code:145,args:[]},"f32.add":{code:146,args:[]},"f32.sub":{code:147,args:[]},"f32.mul":{code:148,args:[]},"f32.div":{code:149,args:[]},"f32.min":{code:150,args:[]},"f32.max":{code:151,args:[]},"f32.copysign":{code:152,args:[]}},An={"f64.const":{code:68,args:["DoubleSignedFloat"]},"f64.eq":{code:97,args:[]},"f64.ne":{code:98,args:[]},"f64.lt":{code:99,args:[]},"f64.gt":{code:100,args:[]},"f64.le":{code:101,args:[]},"f64.ge":{code:102,args:[]},"f64.abs":{code:153,args:[]},"f64.neg":{code:154,args:[]},"f64.ceil":{code:155,args:[]},"f64.floor":{code:156,args:[]},"f64.trunc":{code:157,args:[]},"f64.nearest":{code:158,args:[]},"f64.sqrt":{code:159,args:[]},"f64.add":{code:160,args:[]},"f64.sub":{code:161,args:[]},"f64.mul":{code:162,args:[]},"f64.div":{code:163,args:[]},"f64.min":{code:164,args:[]},"f64.max":{code:165,args:[]},"f64.copysign":{code:166,args:[]}},Vn={"i32.load":{code:40,defaultAlign:2},"i64.load":{code:41,defaultAlign:3},"f32.load":{code:42,defaultAlign:2},"f64.load":{code:43,defaultAlign:3},"i32.load8_s":{code:44,defaultAlign:0},"i32.load8_u":{code:45,defaultAlign:0},"i32.load16_s":{code:46,defaultAlign:0},"i32.load16_u":{code:47,defaultAlign:0},"i64.load8_s":{code:48,defaultAlign:0},"i64.load8_u":{code:49,defaultAlign:0},"i64.load16_s":{code:50,defaultAlign:0},"i64.load16_u":{code:51,defaultAlign:0},"i64.load32_s":{code:52,defaultAlign:0},"i64.load32_u":{code:53,defaultAlign:0},"i32.store":{code:54,defaultAlign:2},"i64.store":{code:55,defaultAlign:3},"f32.store":{code:56,defaultAlign:2},"f64.store":{code:57,defaultAlign:3},"i32.store8":{code:58,defaultAlign:0},"i32.store16":{code:59,defaultAlign:0},"i64.store8":{code:60,defaultAlign:0},"i64.store16":{code:61,defaultAlign:0},"i64.store64":{code:62,defaultAlign:0}},Kn={...Mn,...Cn,...Sn,...An};function Pn(e){return te(e?.value??null)}function qn(e,n){return{kind:"FuncType",paramType:e,resultType:n}}function Dn(e,n){if(e.kind!==n.kind)return!1;if(e.paramType.length!==n.paramType.length)return!1;if(e.resultType.length!==n.resultType.length)return!1;for(let t=0;t<e.paramType.length;t++)if(e.paramType[t].kind!==n.paramType[t].kind)return!1;for(let t=0;t<e.resultType.length;t++)if(e.resultType[t].kind!==n.resultType[t].kind)return!1;return!0}const Bn=e=>{const{args:n}=Kn[e.instructionKind];return ne(e.parameters.map(((t,r)=>n[r]?te(t.value):re({message:`${e.instructionKind} can not have ${r}th param`})))).map((n=>({kind:"NumericInstruction",instructionKind:e.instructionKind,parameters:n})))},zn=Q({ifInstruction:(e,n,t)=>{let r=null;if(e.blockType.type||0!==e.blockType.results.length)if(e.blockType.type||1!==e.blockType.results.length)if(e.blockType.type){const t=En(n.refCtx.types,e.blockType.type);if(!t.ok)return re(t.value);r=t.value}else{const t=qn([],e.blockType.results.map(In)),i=n.types.findIndex((e=>Dn(e,t)));-1===i?(r=n.types.length,n.types.push(t)):r=i}else r=In(e.blockType.results[0]);else r=null;return ee(ne(e.thenExpr.map((e=>t(e,n)))),ne(e.elseExpr.map((e=>t(e,n)))))(((e,n)=>te({kind:"IfInstruction",blockType:r,thenExpr:e,elseExpr:n})))},controlInstruction:(e,{refCtx:n})=>{const{args:t}=Nn[e.instructionKind];return ne(e.parameters.map(((r,i)=>t[i]?En(n[t[i]],"FuncTypeRef"===r.kind?r.type:r):re({message:`${e.instructionKind} can not have ${i}th param`})))).map((n=>({kind:"ControlInstruction",instructionKind:e.instructionKind,parameters:n})))},variableInstruction:(e,{refCtx:n})=>{const{args:t}=jn[e.instructionKind];return ne(e.parameters.map(((r,i)=>t[i]?En(n[t[i]],r):re({message:`${e.instructionKind} can not have ${i}th param`})))).map((n=>({kind:"VariableInstruction",instructionKind:e.instructionKind,parameters:n})))},memoryInstruction:e=>{const{defaultAlign:n}=Vn[e.instructionKind];return ee(Pn(e.offset),Pn(e.align))(((t,r)=>te({kind:"MemoryInstruction",instructionKind:e.instructionKind,offset:t??0,align:r??n})))},int32NumericInstruction:Bn,int64NumericInstruction:Bn,float32NumericInstruction:Bn,float64NumericInstruction:Bn});function On(e){return ee(function(e){return te(e.value)}(e.min),Pn(e.max))(((e,n)=>te({kind:"Limits",min:e,max:n})))}function Wn(e,{refCtx:n,offsetExpr:t}){return t?ee(ne(e.indices.map((e=>En(n.funcs,e)))),ne(t.map((e=>zn(e,{refCtx:n,types:[]})))))(((e,n)=>te({kind:"FunctionIndexList",indices:e,offsetExpr:n}))):ne(e.indices.map((e=>En(n.funcs,e)))).map((e=>({kind:"FunctionIndexList",indices:e,offsetExpr:[{kind:"NumericInstruction",instructionKind:"i32.const",parameters:[0]}]})))}function Rn(e){const n=e=>[...e.entries()].map((([e,n])=>({kind:"NameAssociation",idx:n,name:e})));return{kind:"Names",funcs:n(e.funcs),locals:[...e.funcLocals.entries()].map((([e,t])=>({kind:"IndirectNameMap",idx:e,nameMap:n(t)}))),types:n(e.types),tables:n(e.tables),mems:n(e.mems),globals:n(e.globals)}}function Un(e){if(e<0)throw new Error("Value must not be negative.");const n=[];for(;;){const t=127&e;if(0==(e>>=7)){n.push(t);break}n.push(128|t)}return new Uint8Array(n)}function Gn(e){e|=0;const n=[];for(;;){const t=127&e;if(0==(e>>=7)&&0==(64&t)||-1===e&&0!=(64&t)){n.push(t);break}n.push(128|t)}return new Uint8Array(n)}const Hn=new Uint8Array([0,97,115,109]),Zn=new Uint8Array([1,0,0,0]),Qn={Func:0,Table:1,Memory:2,Global:3};function Xn(e){return new Uint8Array([e])}function Jn(e){return Un(e)}function Yn(e){return Gn(e)}function et(...e){const n=e.reduce(((e,n)=>e+n.byteLength),0),t=new Uint8Array(n);let r=0;for(const n of e)t.set(n,r),r+=n.byteLength;return t}function nt(e){const n=function(e){return(new TextEncoder).encode(e)}(e);return et(Jn(n.byteLength),n)}function tt(e){return et(Jn(e.length),...e)}function rt(e,n){if(!n.length)return new Uint8Array;const t=tt(n);return et(Xn(e),Un(t.byteLength),t)}function it(e){return e.map((({idx:e,name:n})=>et(Jn(e),nt(n))))}function st(e){switch(e.kind){case"Int32Type":return Xn(127);case"Int64Type":return Xn(126);case"Float32Type":return Xn(125);case"Float64Type":return Xn(124);default:throw new Error(`Invalid value type kind: ${e.kind}`)}}function at(e){return et(Xn(96),tt(e.paramType.map(st)),tt(e.resultType.map(st)))}function ot({min:e,max:n}){return n?et(Xn(1),Jn(e),Jn(n)):et(Xn(0),Jn(e))}function lt(e){return e.map((e=>{if("ControlInstruction"===e.kind){const{code:n}=Nn[e.instructionKind];return et(Xn(n),...e.parameters.map((e=>Jn(e))))}if("VariableInstruction"===e.kind){const{code:n}=jn[e.instructionKind];return et(Xn(n),...e.parameters.map((e=>Jn(e))))}if("NumericInstruction"===e.kind){const{code:n,args:t}=Kn[e.instructionKind];return et(Xn(n),...e.parameters.map(((e,n)=>{switch(t[n]){case"SignedInteger":return Yn(e);case"DoubleSignedInteger":return Gn(e);case"SignedFloat":return new Uint8Array(new Float32Array([e]).buffer);case"DoubleSignedFloat":return function(e){return new Uint8Array(new Float64Array([e]).buffer)}(e);default:throw new Error(`invalit argument type: ${t[n]}`)}})))}if("MemoryInstruction"===e.kind){const{code:n}=Vn[e.instructionKind];return et(Xn(n),Jn(e.align),Jn(e.offset))}if("IfInstruction"===e.kind){const t=lt(e.thenExpr),r=lt(e.elseExpr);return et(Xn(Ln.if.code),(n=e.blockType)?"number"==typeof n?Yn(n):st(n):Xn(64),...t,Xn(Ln.else.code),...r,Xn(Ln.end.code))}var n;throw new Error(`${e.kind}`)}))}function ct(e){return et(...lt(e),Xn(11))}function ut(e,{enableNameSection:n}){return n?(t=function(e){return et(nt("name"),rt(1,it(e.funcs)),rt(2,e.locals.map((({idx:e,nameMap:n})=>et(Jn(e),tt(it(n)))))),rt(4,it(e.types)),rt(5,it(e.tables)),rt(6,it(e.mems)),rt(7,it(e.globals)))}(e.names),et(Xn(0),Gn(t.byteLength),t)):new Uint8Array;var t}function dt(e,n){const t=et(Hn,Zn),r=et(t,rt(1,e.types.map(at)),rt(3,e.funcs.map((e=>Jn(e.type)))),rt(4,e.tables.map((e=>et(Xn("Funcref"===e.refType?112:111),ot(e.limits))))),rt(5,e.mems.map((e=>ot(e.limits)))),rt(6,e.globals.map((e=>{return et(et(st((n=e.type).valueType),Xn("Const"===n.mutKind?0:1)),ct(e.expr));var n}))),rt(7,e.exports.map((e=>et(nt(e.name),Xn(Qn[e.exportKind]),Jn(e.index))))),rt(9,e.elems.map((e=>{return n=e.elemList,et(Xn(0),ct(n.offsetExpr),tt(n.indices.map((e=>Jn(e)))));var n}))),rt(10,e.funcs.map((e=>{const n=tt(e.locals.map((e=>et(Jn(1),st(e))))),t=ct(e.body);return et(Jn(n.byteLength+t.byteLength),n,t)}))),ut(e,n));return r}function pt(e,n){return{kind:"SyntacticPlaceholder",index:e,loc:n?.loc}}function ft(e,n){return{kind:"Uint32Literal",value:e,loc:n?.loc}}function mt(e,n){return{kind:"Int32Literal",value:e,loc:n?.loc}}function ht(e,n){return{kind:"Int64Literal",value:e,loc:n?.loc}}function _t(e,n){return{kind:"Float32Literal",value:e,loc:n?.loc}}function gt(e,n){return{kind:"Float64Literal",value:e,loc:n?.loc}}function yt(e,n,t){return{kind:"Limits",min:e,max:n??null,loc:t?.loc}}function kt(e,n,t){return{kind:"Memory",limits:e,id:n??null,loc:t?.loc}}function bt(e,n,t){return{kind:"Module",body:e,id:n??null,loc:t?.loc}}function vt(e,n){return{kind:"Identifier",value:e,loc:n?.loc}}function $t(e,n){return{kind:"ValueType",valueKind:e,loc:n?.loc}}function xt(e,n){return{kind:"MutValueType",valueType:e,loc:n?.loc}}function Tt(e,n,t){return{kind:"ParamType",id:n??null,valueType:e,loc:t?.loc}}function wt(e,n){return{kind:"RefType",refKind:e,loc:n?.loc}}function Et(e,n,t){return{kind:"LocalVar",id:n??null,valueType:e,loc:t?.loc}}function It(e,n,t){return{kind:"FuncType",params:e,results:n,loc:t?.loc}}function Ft(e,n,t){return{kind:"Type",funcType:e,id:n??null,loc:t?.loc}}function Lt(e,n){return{kind:"FuncTypeRef",type:e,loc:n?.loc}}function Nt(e,n,t,r){return{kind:"FuncSig",type:t??null,params:e,results:n,loc:r?.loc}}function jt(e,n,t){return{kind:"BlockType",type:n??null,results:e,loc:t?.loc}}function Mt(e,n,t,r,i){return{kind:"IfInstruction",blockType:e,thenExpr:n,elseExpr:t,id:r??null,elseId:r??null,endId:r??null,loc:i?.loc}}function Ct(e,n,t){return{kind:"ControlInstruction",instructionKind:e,parameters:n??[],loc:t?.loc}}function St(e,n,t){return{kind:"VariableInstruction",instructionKind:e,parameters:n??[],loc:t?.loc}}function At(e,n,t){return{kind:"Int32NumericInstruction",instructionKind:e,parameters:n??[],loc:t?.loc}}function Vt(e,n,t){return{kind:"Int64NumericInstruction",instructionKind:e,parameters:n??[],loc:t?.loc}}function Kt(e,n,t){return{kind:"Float32NumericInstruction",instructionKind:e,parameters:n??[],loc:t?.loc}}function Pt(e,n,t){return{kind:"Float64NumericInstruction",instructionKind:e,parameters:n??[],loc:t?.loc}}function qt(e,n,t,r){return{kind:"MemoryInstruction",instructionKind:e,offset:n??null,align:t??null,loc:r?.loc}}function Dt(e,n,t,r,i){return{kind:"Func",id:r??null,signature:e,locals:n,instructions:t,loc:i?.loc}}function Bt(e,n,t){return{kind:"TableType",refType:e,limits:n,loc:t?.loc}}function zt(e,n,t){return{kind:"Table",id:n??null,tableType:e,elemList:null,loc:t?.loc}}function Ot(e,n){return{kind:"FunctionIndexList",indices:e,loc:n?.loc}}function Wt(e,n,t,r){return{kind:"Global",id:t??null,expr:n,type:e,loc:r?.loc}}function Rt(e,n,t,r){return{kind:"Elem",elemList:e,offsetExpr:n,id:t??null,loc:r?.loc}}function Ut(e,n,t){return{kind:"Table",elemList:e,id:n??null,tableType:null,loc:t?.loc}}function Gt(e,n){return{kind:"ExportedFunc",index:e,loc:n?.loc}}function Ht(e,n){return{kind:"ExportedMemory",index:e,loc:n?.loc}}function Zt(e,n){return{kind:"ExportedTable",index:e,loc:n?.loc}}function Qt(e,n){return{kind:"ExportedGlobal",index:e,loc:n?.loc}}function Xt(e,n,t){return{kind:"Export",name:e,sec:n,loc:t?.loc}}const Jt=r;function Yt(e,n){return function(e){const{typedefNodes:n,funcNodes:t,tableNodes:r,memNodes:i,globalNodes:s,exportNodes:a,elemNodes:o,refCtx:l}=function(e){const n={types:new Map,funcs:new Map,globals:new Map,elem:new Map,mems:new Map,tables:new Map,funcLocals:new Map},t=[],r=[],i=[],s=[],a=[],o=[],l=[];for(const n of e.body)switch(n.kind){case"Type":t.push(n);break;case"Func":r.push(n);break;case"Table":i.push(n);break;case"Memory":s.push(n);break;case"Export":a.push(n);break;case"Global":o.push(n);break;case"Elem":l.push(n)}return wn(t,n.types),wn(r,n.funcs),wn(i,n.tables),wn(s,n.mems),wn(o,n.globals),wn(l,n.elem),{typedefNodes:t,funcNodes:r,tableNodes:i,memNodes:s,globalNodes:o,exportNodes:a,elemNodes:l,refCtx:n}}(e);return ne(n.map((e=>function(e){return te({kind:"FuncType",paramType:Fn(e.funcType.params),resultType:e.funcType.results.map(In)})}(e)))).mapValue((e=>ee(ne(i.map((e=>function(e){return On(e.limits).map((e=>({kind:"MemType",limits:e})))}(e)))),t.reduce(((e,n,t)=>e.mapValue((e=>function(e,n,t,r){const i=new Map;let s,a=t;const{signature:o}=e;if(null===o.type){const n=qn(Fn(o.params),o.results.map(In)),r=t.types.findIndex((e=>Dn(e,n)));-1===r?(s=t.types.length,a={...t,types:[...t.types,n]}):s=r,wn([...o.params,...e.locals],i)}else{const n=En(r.types,o.type);if(!n.ok)return re(n.value);s=n.value,wn(e.locals,i)}r.funcLocals.set(n,i);const l=a.types.slice();return ne(e.instructions.map((e=>zn(e,{refCtx:{...r,locals:i},types:l})))).map((n=>({kind:"Func",type:s,locals:Fn(e.locals),body:n}))).map((e=>({types:l,funcs:[...t.funcs,e]})))}(n,t,e,l)))),te({funcs:[],types:e})),ne(o.map((e=>function(e,n){return Wn(e.elemList,{refCtx:n,offsetExpr:e.offsetExpr}).map((e=>({kind:"Elem",elemList:e})))}(e,l)))),ne(a.map((e=>function(e,n){return"ExportedFunc"===e.sec.kind?En(n.funcs,e.sec.index).map((n=>({kind:"Export",name:e.name,exportKind:"Func",index:n}))):"ExportedMemory"===e.sec.kind?En(n.mems,e.sec.index).map((n=>({kind:"Export",name:e.name,exportKind:"Memory",index:n}))):"ExportedTable"===e.sec.kind?En(n.tables,e.sec.index).map((n=>({kind:"Export",name:e.name,exportKind:"Table",index:n}))):"ExportedGlobal"===e.sec.kind?En(n.globals,e.sec.index).map((n=>({kind:"Export",name:e.name,exportKind:"Global",index:n}))):void 0}(e,l)))),ne(s.map((e=>function(e,n){return ne(e.expr.map((e=>zn(e,{refCtx:n,types:[]})))).map((n=>({kind:"Global",expr:n,type:{kind:"GlobalType",mutKind:"MutValueType"===e.type.kind?"Var":"Const",valueType:"ValueType"===e.type.kind?In(e.type):In(e.type.valueType)}})))}(e,l)))))(((e,{funcs:n,types:t},i,s,a)=>r.reduce(((e,n)=>e.mapValue((e=>function(e,n,t){if(n.tables.length>0)return re({message:"Module can't have two or more tables."});if(e.tableType&&!e.elemList){const{tableType:t}=e;return On(t.limits).map((e=>({...n,tables:[...n.tables,{kind:"TableType",limits:e,refType:t.refType.refKind}]})))}if(e.elemList&&!e.tableType){const{elemList:r}=e,i={kind:"Limits",min:r.indices.length,max:r.indices.length};return Wn(r,{refCtx:t,offsetExpr:null}).map((e=>({tables:[{kind:"TableType",limits:i,refType:"Funcref"}],elems:[...n.elems,{kind:"Elem",elemList:e}]})))}return re({message:"Invalid table node"})}(n,e,l)))),te({tables:[],elems:i})).map((({tables:r,elems:i})=>({kind:"Module",names:Rn(l),types:t,funcs:n,tables:r,mems:e,globals:a,exports:s,elems:i})))))))}(e).map((e=>dt(e,n)))}const er={name:"lib/allocator",code:"\n    (module\n      (memory $__alloc_mem__ 10)\n      (global $__alloc_st__ (mut i32) i32.const 4)\n      (func $__malloc__ (param $size i32) (result i32) (local $next i32)\n\n        global.get $__alloc_st__\n        local.set $next\n\n        global.get $__alloc_st__\n        local.get $size\n        i32.add\n\n        global.set $__alloc_st__\n        local.get $next\n      )\n    )\n  "};function nr(){return er}const{visitEachChild:tr}=J(["align","blockType","body","elemList","elseExpr","elseId","endId","expr","funcType","id","index","indices","instructions","limits","locals","max","min","name","offset","offsetExpr","parameters","params","refKind","refType","results","sec","signature","tableType","thenExpr","type","valueType"]);class rr extends fe{_blockComment(e){if(!this.input.slice(e).startsWith("(;"))return 0;let n=1,t=2;for(;n>0&&e+t<this.input.length;)";)"===this.input.substr(e+t,2)?(t+=2,n--):"(;"===this.input.substr(e+t,2)?(t+=2,n++):++t;return t}_lineComment(e){if(!this.input.slice(e).startsWith(";;"))return 0;let n=2;for(;e+n<this.input.length&&"\n"!==this.input[e+n];)++n;return n}leadingComment(e){let n=0;for(;;){const t=this._lineComment(e+n),r=this._blockComment(e+n+t);if(t+r===0)break;n+=t+r}return n}}function ir(e){return n=>"NullPosition"===e._brand?null:n(e)}const sr=e=>n=>{const t=n.pos,r=e(n);return r.ok?r:(n.back(t),r.error((e=>({...e,confirmed:!1}))))},ar=e=>n=>{const t=e(n);return t.ok?te(t.value):te(function(e){return{_brand:"NullPosition",_nodeId:"null",loc:{pos:e.pos,end:e.pos}}}(n))},or=e=>n=>n.startsWith(e)?te({tokenKind:"Symbol",symbol:e,loc:n.consume(e.length)}):re({confirmed:!1,message:`'${e}' expected.`,occurence:{loc:{pos:n.pos,end:n.pos+1}}}),lr=e=>n=>n.startsWith(e)?te({tokenKind:"Keyword",keyword:e,loc:n.consume(e.length)}):re({confirmed:!1,message:`'${e}' expected.`,occurence:{loc:{pos:n.pos,end:n.pos+1}}}),cr=e=>n=>n.startsWith(e)&&n.match(/^($|[^a-zA-Z0-9\.\$_])/,e.length)?te({tokenKind:"Keyword",keyword:e,loc:n.consume(e.length)}):re({confirmed:!1,message:`'${e}' expected.`,occurence:{loc:{pos:n.pos,end:n.pos+1}}}),ur=e=>se(...e.map((e=>cr(e)))),dr=e=>{const n=e.match(/^(\$[a-zA-Z0-9\!#\$%&'\*\+\-\.\/:<=>\?@\\\^_`\|\~]+)/);return n?te({tokenKind:"Identifier",name:n[1].slice(1),loc:e.consume(n[1].length)}):re({confirmed:!1,message:"Identifier expected.",occurence:{loc:{pos:e.pos,end:e.pos+1}}})},pr=e=>n=>{const t=e?n.match(/^([\+-]?\d+)/):n.match(/(^\d+)/);return t?te({tokenKind:"Int",value:parseInt(t[1],10),loc:n.consume(t[1].length)}):re({confirmed:!1,message:"Integer expected.",occurence:{loc:{pos:n.pos,end:n.pos+1}}})},fr=pr(!0),mr=pr(!1),hr=e=>{const n=e.match(/^([\+-]?\d+)/);if(!n)return re({confirmed:!1,message:"Decimal number expected.",occurence:{loc:{pos:e.pos,end:e.pos+1}}});const t=e.match(/^(\.\d*)/,n[1].length),r=n[1]+(t?t[1]:"");return te({tokenKind:"Decimal",value:parseFloat(r),loc:e.consume(r.length)})},_r=e=>{const n=e.match(/^%%PLACEHOLDER_(\d+)%%/);return n?te({kind:"SyntacticPlaceholder",index:parseInt(n[1],10),loc:e.consume(n[0].length)}):re({message:"placeholder expected",confirmed:!1,occurence:{loc:{pos:e.pos,end:e.pos+1}}})},gr=e=>se(e,_r),yr=oe(dr)((e=>({kind:"Identifier",value:e.name,loc:e.loc}))),kr=e=>ir(e)((e=>({kind:"Identifier",value:e.name,loc:e.loc}))),br=oe(mr)((e=>({kind:"Uint32Literal",value:e.value,...ue(e)}))),vr=oe(fr)((e=>({kind:"Int32Literal",value:e.value,...ue(e)}))),$r=oe(fr)((e=>({kind:"Int64Literal",value:e.value,...ue(e)}))),xr=oe(hr)((e=>({kind:"Float32Literal",value:e.value,...ue(e)}))),Tr=oe(hr)((e=>({kind:"Float64Literal",value:e.value,...ue(e)}))),wr=se(yr,br),Er=oe(se(cr("i32"),cr("i64"),cr("f32"),cr("f64")))((e=>({kind:"ValueType",valueKind:e.keyword,...ue(e)}))),Ir=sr(oe(or("("),cr("param"),ar(dr),Er,or(")"))(((e,n,t,r,i)=>({kind:"ParamType",id:kr(t),valueType:r,...ue(e,n,t,r,i)})))),Fr=sr(oe(or("("),cr("mut"),Er,or(")"))(((e,n,t,r)=>({kind:"MutValueType",valueType:t,...ue(e,n,t,r)})))),Lr=sr(oe(or("("),cr("result"),se(cr("i32"),cr("i64"),cr("f32"),cr("f64")),or(")"))(((e,n,t,r)=>({kind:"ValueType",valueKind:t.keyword,...ue(e,n,t,r)})))),Nr=sr(oe(or("("),cr("func"),ye(Ir),ye(Lr),or(")"))(((e,n,t,r,i)=>({kind:"FuncType",params:t.values,results:r.values,...ue(e,n,t,r,i)})))),jr=sr(oe(or("("),cr("type"),ar(dr),Nr,or(")"))(((e,n,t,r,i)=>({kind:"Type",id:kr(t),funcType:r,...ue(e,n,t,r,i)})))),Mr=sr(oe(or("("),cr("type"),wr,or(")"))(((e,n,t,r)=>({...t,...ue(e,n,t,r)})))),Cr=sr(oe(ar(Mr),ye(Ir),ye(Lr))(((e,n,t)=>({kind:"FuncSig",type:ir(e)((e=>e)),params:n.values,results:t.values,...ue(e,n,t)})))),Sr=sr(oe(ar(Mr),ye(Lr))(((e,n)=>({kind:"BlockType",type:ir(e)((e=>e)),results:n.values,...ue(e,n)})))),Ar=sr(oe(cr("if"),ar(dr),Sr,ye(ae((()=>Ur))),cr("else"),ar(dr),ye(ae((()=>Ur))),cr("end"),ar(dr))(((e,n,t,r,i,s,a,o,l)=>({kind:"IfInstruction",id:kr(n),elseId:kr(s),endId:kr(l),blockType:t,thenExpr:r.values,elseExpr:a.values,...ue(e,n,t,r,i,s,a,o,l)})))),Vr=sr(oe(Mr)((e=>({kind:"FuncTypeRef",type:e,loc:e.loc})))),Kr=sr(oe(ur(Object.keys(Nn)),ye(se(wr,Vr)))(((e,n)=>({kind:"ControlInstruction",instructionKind:e.keyword,parameters:n.values,...ue(e,n)})))),Pr=sr(oe(ur(Object.keys(jn)),ye(wr))(((e,n)=>({kind:"VariableInstruction",instructionKind:e.keyword,parameters:n.values,...ue(e,n)})))),qr=sr(oe(ur(Object.keys(Mn)),ye(vr))(((e,n)=>({kind:"Int32NumericInstruction",instructionKind:e.keyword,parameters:n.values,...ue(e,n)})))),Dr=sr(oe(ur(Object.keys(Cn)),ye($r))(((e,n)=>({kind:"Int64NumericInstruction",instructionKind:e.keyword,parameters:n.values,...ue(e,n)})))),Br=sr(oe(ur(Object.keys(Sn)),ye(xr))(((e,n)=>({kind:"Float32NumericInstruction",instructionKind:e.keyword,parameters:n.values,...ue(e,n)})))),zr=sr(oe(ur(Object.keys(An)),ye(Tr))(((e,n)=>({kind:"Float64NumericInstruction",instructionKind:e.keyword,parameters:n.values,...ue(e,n)})))),Or=sr(oe(ur(Object.keys(Vn)),ar(oe(lr("offset="),br)(((e,n)=>({...n,...ue(e,n)})))),ar(oe(lr("align="),br)(((e,n)=>({...n,...ue(e,n)})))))(((e,n,t)=>({kind:"MemoryInstruction",instructionKind:e.keyword,offset:ir(n)((e=>e)),align:ir(t)((e=>e)),...ue(e,n,t)})))),Wr=sr(oe(or("("),cr("local"),ar(dr),Er,or(")"))(((e,n,t,r,i)=>({kind:"LocalVar",id:kr(t),valueType:r,...ue(e,n,t,r,i)})))),Rr=se(qr,Dr,Br,zr),Ur=gr(se(Ar,Kr,Rr,Pr,Or)),Gr=sr(oe(or("("),cr("func"),ar(dr),Cr,ye(Wr),ye(Ur),or(")"))(((e,n,t,r,i,s,a)=>({kind:"Func",id:kr(t),signature:r,locals:i.values,instructions:s.values,...ue(e,n,t,r,i,s,a)})))),Hr=oe(br,ar(br))(((e,n)=>({kind:"Limits",min:e,max:ir(n)((e=>e)),...ue(e,n)}))),Zr=sr(oe(or("("),cr("memory"),ar(dr),Hr,or(")"))(((e,n,t,r,i)=>({kind:"Memory",id:kr(t),limits:r,...ue(e,n,t,r,i)})))),Qr=sr(oe(or("("),cr("global"),ar(dr),se(Er,Fr),ye(Ur),or(")"))(((e,n,t,r,i,s)=>({kind:"Global",id:kr(t),type:r,expr:i.values,...ue(e,n,t,r,i,s)})))),Xr=sr(oe(or("("),cr("elem"),ye(wr),or(")"))(((e,n,t,r)=>({kind:"FunctionIndexList",indices:t.values,...ue(e,n,t,r)})))),Jr=sr(oe(cr("func"),ye(wr))(((e,n)=>({kind:"FunctionIndexList",indices:n.values,...ue(e,n)})))),Yr=sr(oe(or("("),cr("table"),ar(dr),Hr,se(cr("funcref"),cr("externref")),or(")"))(((e,n,t,r,i,s)=>({kind:"Table",elemList:null,id:kr(t),tableType:{kind:"TableType",limits:r,refType:{kind:"RefType",refKind:"funcref"===i.keyword?"Funcref":"Externref",...ue(i)},...ue(r)},...ue(e,n,t,r,i,s)})))),ei=sr(oe(or("("),cr("table"),ar(dr),cr("funcref"),Xr,or(")"))(((e,n,t,r,i,s)=>({kind:"Table",id:kr(t),elemList:i,tableType:null,...ue(e,n,t,r,i,s)})))),ni=se(Yr,ei),ti=sr(oe(or("("),cr("elem"),ar(dr),or("("),cr("offset"),ye(Ur),or(")"),Jr,or(")"))(((e,n,t,r,i,s,a,o,l)=>({kind:"Elem",id:kr(t),elemList:o,offsetExpr:s.values,...ue(e,n,t,r,i,s,a,o,l)})))),ri=sr(oe(or("("),se(cr("func"),cr("memory"),cr("table"),cr("global")),wr,or(")"))(((e,n,t,r)=>({kind:"func"===n.keyword?"ExportedFunc":"memory"===n.keyword?"ExportedMemory":"table"===n.keyword?"ExportedTable":"ExportedGlobal",index:t,...ue(e,n,t,r)})))),ii=sr(oe(or("("),cr("export"),(e=>{if(!e.startsWith('"'))return re({confirmed:!1,message:"String expected.",occurence:{loc:{pos:e.pos,end:e.pos+1}}});let n=0;for(;e.hasNext(++n);)if(e.startsWith("\\",n)&&e.startsWith('"',n+1))n++;else if(e.startsWith('"',n))break;return te({tokenKind:"String",value:e.slice(n).slice(1).replace("\\\t","\t").replace("\\\n","\n").replace("\\\r","\r").replace('\\"','"').replace("\\'","'").replace("\\\\","\\"),loc:e.consume(n+1)})}),ri,or(")"))(((e,n,t,r,i)=>({kind:"Export",name:t.value,sec:r,...ue(e,n,t,r,i)})))),si=se(jr,Gr,ni,Zr,Qr,ii,ti),ai=oe(or("("),cr("module"),ar(dr),ye(gr(si)),or(")"))(((e,n,t,r,i)=>({kind:"Module",id:kr(t),body:r.values,...ue(e,n,t,r,i)}))),oi=ye(Ur),li=(ye(gr(si)),Wr),ci=ai;function ui(e,...n){let t=e[0],r=0;const i=[];for(let s=1;s<e.length;s++)"string"==typeof n[s-1]||"number"==typeof n[s-1]?t+=`${n[s-1]}`+e[s]:(i.push(n[s-1]),t+=` %%PLACEHOLDER_${r++}%% `,t+=e[s]);return{srcString:t,nodeFn:i}}const di=new class{_maxSize;_cacheMap=new Map;constructor(e=100){this._maxSize=e}set(e,n){if(this._cacheMap.set(e,n),this._cacheMap.size>this._maxSize){const e=this._cacheMap.keys().next();this._cacheMap.delete(e.value)}}get(e){const n=this._cacheMap.get(e);if(n)return n}has(e){return this._cacheMap.has(e)}touch(e){const n=this._cacheMap.get(e);n&&(this._cacheMap.delete(e),this._cacheMap.set(e,n))}del(e){this._cacheMap.delete(e)}clearAll(){this._cacheMap=new Map}}(1e3);function pi(e,n,t,r){const i=di.get(e+n);if(i)return r(i);const s=t(e+n);return di.set(n,s),r(s)}const fi=function(e,...n){const{srcString:t,nodeFn:r}=ui(e,...n);return pi("instructions",t,(()=>oi(new rr(t)).unwrap().values),(e=>function(e,n){return()=>{const t=e=>{if("SyntacticPlaceholder"!==e.kind){const{_nodeId:n,loc:r,...i}=tr(e,t);return{...i,loc:void 0}}return n[e.index]()};return e.map((e=>t(e))).flat()}}(e,r)))},mi=function(e,...n){const{srcString:t,nodeFn:r}=ui(e,...n);return pi("localVar",t,(()=>li(new rr(t)).unwrap()),(e=>function(e,n){return()=>{const t=e=>{if("SyntacticPlaceholder"!==e.kind){const{_nodeId:n,loc:r,...i}=tr(e,t);return{...i,loc:void 0}}return n[e.index]()};return t(e)}}(e,r)))};function hi(e,n){if(!e.parameters.length)return!1;const t=e.parameters[0];return"Identifier"===t.kind&&t.value===n}function _i(e,n){return"ControlInstruction"===e.kind&&"call"===e.instructionKind&&hi(e,n)}const gi={name:"lib/float",code:'\n    (module\n      (func $__float_new__ (param $value f64) (result i32) (local $addr i32)\n        i32.const 8\n        call $__malloc__\n        local.tee $addr\n        local.get $value\n        f64.store offset=0\n        local.get $addr\n\n        ;; Note:\n        ;; We should add the following tag to LSB 4-bits of the floating-point number address.\n        ;; [0010] = 0x2\n\n        i32.const 4\n        i32.shl \n        i32.const 2\n        i32.or\n      )\n      (func $__float_get__ (param $addr i32) (result f64)\n        local.get $addr\n        i32.const 4\n        i32.shr_u\n        f64.load offset=0\n      )\n      (export "__float_get__" (func $__float_get__))\n    )\n  ',dependencies:[nr()]};function yi(){return gi}const ki=fi`
  call $__float_new__
`,bi=fi`
  call $__float_get__
`,vi=e=>e.reduce(((e,n)=>{if(!_i(n,"__float_get__"))return[...e,n];const t=e.slice(-1);return t.length&&_i(t[0],"__float_new__")?e.slice(0,e.length-1):[...e,n]}),[]),$i={name:"lib/tuple",dependencies:[nr()],code:"\n    (module\n      (func $__tuple_new__ (param $v0 i32) (param $v1 i32) (result i32) (local $addr i32)\n        i32.const 8\n        call $__malloc__\n        local.set $addr\n\n        local.get $addr\n        local.get $v0\n        i32.store offset=0\n\n        local.get $addr\n        local.get $v1\n        i32.store offset=4\n\n        local.get $addr\n      )\n      (func $__tuple_get_v0__ (param $addr i32) (result i32)\n        local.get $addr\n        i32.load offset=0\n      )\n      (func $__tuple_get_v1__ (param $addr i32) (result i32)\n        local.get $addr\n        i32.load offset=4\n      )\n    )\n  "};function xi(){return $i}const Ti=fi`
  call $__tuple_new__
`,wi=e=>fi`
    call $__tuple_get_v${e}__
  `(),Ei={name:"lib/list",dependencies:[xi()],code:'\n    (module\n      (func $__list_new__ (result i32)\n        i32.const 0\n      )\n\n      (func $__list_push__ (param $list_addr i32) (param $value i32) (result i32)\n        local.get $list_addr\n        local.get $value\n        call $__tuple_new__\n\n        ;; Note:\n        ;; We should add the following tag to LSB 4-bits of the list address.\n        ;; [0100] = 0x4\n        i32.const 4\n        i32.shl\n        i32.const 4\n        i32.or\n      )\n\n      (func $__list_is_empty__ (param $list_addr i32) (result i32)\n        local.get $list_addr\n        i32.const 0\n        i32.eq\n      )\n\n      (func $__list_head__ (param $list_addr i32) (result i32)\n        local.get $list_addr\n        i32.const 4\n        i32.shr_u\n        call $__tuple_get_v1__\n      )\n\n      (func $__list_tail__ (param $list_addr i32) (result i32)\n        local.get $list_addr\n        i32.const 4\n        i32.shr_u\n        call $__tuple_get_v0__\n      )\n\n      (export "__list_head__" (func $__list_head__))\n      (export "__list_tail__" (func $__list_tail__))\n    )\n  '};function Ii(){return Ei}const Fi=fi`
  call $__list_new__
`,Li=fi`
  call $__list_push__
`,Ni=(fi`
  call $__list_is_empty__
`,fi`
  call $__list_head__
`),ji=fi`
  call $__list_tail__
`,Mi={name:"lib/environment",dependencies:[xi()],code:"\n    (module\n      (func $__env_new__ (param $parent_addr i32) (param $value i32) (result i32)\n        local.get $parent_addr\n        local.get $value\n        call $__tuple_new__\n      )\n\n      (func $__env_get__ (param $addr i32) (param $idx i32) (result i32)\n        local.get $idx\n        if (result i32)\n          local.get $addr\n          i32.load\n          local.get $idx\n          i32.const 1\n          i32.sub\n          call $__env_get__\n        else\n          local.get $addr\n          call $__tuple_get_v1__\n        end\n      )\n\n      (func $__env_parent__ (param $addr i32) (result i32)\n        local.get $addr\n        call $__tuple_get_v0__\n      )\n    )\n  "};function Ci(){return Mi}function Si(){return Jt.paramType(Jt.valueType("i32"),Jt.identifier("current_env_addr"))}const Ai=fi`
  i32.const -1
  local.set $current_env_addr
`,Vi=fi`
  call $__env_new__
`,Ki=fi`
  ${Vi}
  local.set $current_env_addr
`,Pi=fi`
  local.get $current_env_addr
`,qi=fi`
  local.set $current_env_addr
`,Di=fi`
  local.get $current_env_addr
  call $__env_parent__
  local.set $current_env_addr
`;function Bi(e){if(e.length<3)return e;const[n,t,r]=e.slice(-3);return"current_env_addr","VariableInstruction"===(i=n).kind&&"local.get"===i.instructionKind&&hi(i,"current_env_addr")&&_i(t,"__env_parent__")&&function(e,n){return"VariableInstruction"===e.kind&&"local.set"===e.instructionKind&&hi(e,"current_env_addr")}(r)?e.slice(0,e.length-3):e;var i}const zi={name:"lib/matcher",dependencies:[Ci(),Ii()],code:"\n    (module\n      (func $__matcher_is_matched_wildcard_pattern__ (param $current_env i32) (param $value i32) (result i32)\n        local.get $current_env\n      )\n\n      (func $__matcher_is_matched_empty_list_pattern__ (param $current_env i32) (param $value i32) (result i32)\n        local.get $value\n        call $__list_is_empty__\n        if (result i32)\n          local.get $current_env\n        else\n          i32.const 0\n        end\n      )\n\n      (func $__matcher_is_matched_identifier_pattern__ (param $current_env i32) (param $value i32) (result i32)\n        local.get $current_env\n        local.get $value\n        call $__env_new__\n      )\n    )\n  "},Oi=fi`
  call $__matcher_is_matched_wildcard_pattern__
`,Wi=fi`
  call $__matcher_is_matched_empty_list_pattern__
`,Ri=fi`
  call $__matcher_is_matched_identifier_pattern__
`;function Ui(e,n){return{getIndex:t=>t.name===e.name?te(0):n.getIndex(t).map((e=>e+1))}}class Gi{touched=!1;funcNodes=[];localVarNodes=[];level=0;get isInFunctionDefinition(){return this.level>0}enter(){return this.level++,this.touched||(this.touched=!0),this.funcNodes.length}leave(e){this.level--;const n=this.funcNodes.length,t=Jt.func(Jt.funcSig([Si()],[Jt.valueType("i32")]),this.localVarNodes,e,function(e){return Jt.identifier(`__fn_${e}__`)}(n));return this.funcNodes.push(t),this.localVarNodes=[],n}useLocalVar(e){e.id&&(this.localVarNodes.some((n=>n.id?.value===e.id.value))||this.localVarNodes.push(e))}buildFuncs(){return this.touched?[Jt.typedef(Jt.funcType([{...Si(),id:null}],[Jt.valueType("i32")]),Jt.identifier("__fn_type__")),...this.funcNodes.slice()]:[]}buildTables(){if(!this.touched)return[];const e=this.funcNodes.map((e=>e.id));return[Jt.tableWithElemList(Jt.functionIndexList(e),Jt.identifier("__func_table__"))]}callInstr=fi`
    call_indirect $__func_table__ $__fn_type__
  `}class Hi{funcNodes=[];enter(){return this.funcNodes.length}leave(e){const n=Jt.identifier(`__matcher_${this.funcNodes.length}__`),t=Jt.func(Jt.funcSig([Si(),Jt.paramType(Jt.valueType("i32"),Jt.identifier("value"))],[Jt.valueType("i32")]),[],e,n);return this.funcNodes.push(t),n}buildFuncs(){return this.funcNodes.slice()}}const Zi=(e,{withFloat:n,withList:t})=>n||t?`\n    (func $__comparator_poly_${e}__ (param $left i32) (param $right i32) (result i32) (local $tag i32)\n      local.get $left\n      i32.const 1\n      i32.and\n      if (result i32)\n        ;; $left is true or signed-integer\n        local.get $left\n        local.get $right\n        i32.${e}_s\n      else\n        ;; $left is false or empty list or address\n        local.get $left\n        if (result i32)\n          local.get $left\n          i32.const 14\n          i32.and\n          local.set $tag\n          ${n?`\n        local.get $tag\n        i32.const 2\n        i32.eq\n        if (result i32)\n          ;; $left and $right is floating-point number\n          local.get $left\n          call $__float_get__\n          local.get $right\n          call $__float_get__\n          f64.${e}\n        else\n    `:""}\n            ${t?`\n        local.get $tag\n        i32.const 4\n        i32.eq\n        if (result i32)\n          ;; $left is non-empty list\n          local.get $left\n          local.get $right\n          call $__comparator_list_${e}__\n        else\n       `:""}\n              unreachable\n            ${t?"end":""}\n          ${n?"end":""}\n        else\n          ;; $left is false or emptyList\n          local.get $left\n          local.get $right\n          i32.${e}_s\n        end\n      end\n    )\n  `:`\n      (func $__comparator_poly_${e}__ (param $left i32) (param $right i32) (result i32)\n        local.get $left\n        local.get $right\n        i32.${e}_s\n      )\n    `,Qi=e=>`\n  (func $__comparator_list_${e}__ (param $l1 i32) (param $l2 i32) (result i32) (local $h1 i32) (local $h2 i32)\n    local.get $l1\n    if (result i32)\n      local.get $l2\n      if (result i32)\n        local.get $l1\n        call $__list_head__\n        local.tee $h1\n        local.get $l2\n        call $__list_head__\n        local.tee $h2\n        call $__comparator_poly_${e}__\n        if (result i32)\n          i32.const 1\n        else\n          local.get $h1\n          local.get $h2\n          call $__comparator_poly_eq__\n          if (result i32)\n            local.get $l1\n            call $__list_tail__\n            local.get $l2\n            call $__list_tail__\n            call $__comparator_list_${e}__\n          else\n            i32.const 0\n          end\n        end\n      else\n        ${"gt"===e||"ge"===e?"i32.const 1":"i32.const 0"}\n      end\n    else\n      local.get $l1\n      local.get $l2\n      ${"eq"===e?"i32.eq":"i32."+e+"_s"}\n    end\n  )\n`,Xi=({withFloat:e,withList:n})=>e||n?`\n    (func $__comparator_poly_eq__ (param $left i32) (param $right i32) (result i32) (local $tag i32)\n      local.get $left\n      i32.const 1\n      i32.and\n      if (result i32)\n        local.get $left\n        local.get $right\n        i32.eq\n      else\n        local.get $left\n        if (result i32)\n          local.get $left\n          i32.const 14\n          i32.and\n          local.set $tag\n          ${e?"\n        local.get $tag\n        i32.const 2\n        i32.eq\n        if (result i32)\n          ;; $left and $right is floating-point number\n          local.get $left\n          call $__float_get__\n          local.get $right\n          call $__float_get__\n          f64.eq\n        else\n    ":""}\n            ${n?"\n        local.get $tag\n        i32.const 4\n        i32.eq\n        if (result i32)\n          ;; $left is non-empty list\n          local.get $left\n          local.get $right\n          call $__comparator_list_eq__\n        else\n       ":""}\n              unreachable\n            ${n?"end":""}\n          ${e?"end":""}\n        else\n          local.get $left\n          local.get $right\n          i32.eq\n        end\n      end\n    )\n  `:"\n      (func $__comparator_poly_eq__ (param $left i32) (param $right i32) (result i32)\n        local.get $left\n        local.get $right\n        i32.eq\n      )\n    ",Ji=e=>fi`
    call $__comparator_poly_${e}__
  `();function Yi(e){return"eq"==e||"ne"==e?[Jt.int32NumericInstr(`i32.${e}`)]:[Jt.int32NumericInstr(`i32.${e}_s`)]}const es=e=>fi`
    f64.${e}
  `();class ns{_options;_env=function(){return{getIndex:e=>re({message:`No identifier: ${e.name}`})}}();_instructions=[];_enabledAllocator=!1;_enabledFloat=!1;_enabledList=!1;_enabledTuple=!1;_enabledEnv=!1;_enabledMatcher=!1;_enableComparator=!1;_includingComparisonOperators=[];_localsMainFn=[];_dependencies=[];funcDefStack=new Gi;matcherDefStack=new Hi;constructor(e={typeValueMap:new Map}){this._options=e}getOptions(){return this._options}pushInstruction(e){Array.isArray(e)?e.forEach((e=>this._instructions.push(e))):this._instructions.push(e)}getInstructions(){return this._instructions}getDependencies(){if(this._enableComparator){const e=function({includeOperators:e,withFloat:n,withList:t}){const r=-1!==e.indexOf("eq"),i=-1!==e.indexOf("ne"),s=-1!==e.indexOf("lt"),a=-1!==e.indexOf("le"),o=-1!==e.indexOf("gt"),l=-1!==e.indexOf("ge");return{name:"lib/comparator",code:`\n      (module\n\n        ${s?Zi("lt",{withList:t,withFloat:n}):""}\n        ${s&&t?Qi("lt"):""}\n\n        ${a?Zi("le",{withList:t,withFloat:n}):""}\n        ${a&&t?Qi("le"):""}\n\n        ${o?Zi("gt",{withList:t,withFloat:n}):""}\n        ${o&&t?Qi("gt"):""}\n\n        ${l?Zi("ge",{withList:t,withFloat:n}):""}\n        ${l&&t?Qi("ge"):""}\n\n        ${t?Qi("eq"):""}\n        ${r||i||t?Xi({withList:t,withFloat:n}):""}\n\n        ${i?"\n  (func $__comparator_poly_ne__ (param $left i32) (param $right i32) (result i32)\n    local.get $left\n    local.get $right\n    call $__comparator_poly_eq__\n    i32.const 1\n    i32.xor\n  )\n":""}\n      )\n    `,dependencies:[...n?[yi()]:[],...t?[Ii()]:[]]}}({includeOperators:this._includingComparisonOperators,withFloat:this._enabledFloat,withList:this._enabledList});return[...this._dependencies,e]}return this._dependencies}setEnv(e){this._env=e}getEnv(){return this._env}getLocalsMainFn(){return this._localsMainFn}useLocalVar(e){if(e.id)if(this.funcDefStack.isInFunctionDefinition)this.funcDefStack.useLocalVar(e);else{if(this._localsMainFn.some((n=>n.id?.value===e.id.value)))return;this._localsMainFn.push(e)}}useAllocator(){this._enabledAllocator||(this._enabledAllocator=!0,this._dependencies.push(nr()))}useFloat(){this._enabledFloat||(this._enabledFloat=!0,this._dependencies.push(yi()))}useList(){this._enabledList||(this._enabledList=!0,this._dependencies.push(Ii()))}useTuple(){this._enabledTuple||(this._enabledTuple=!0,this._dependencies.push(xi()))}useEnvironment(){this._enabledEnv||(this._enabledEnv=!0,this._dependencies.push(Ci()),this._localsMainFn.push(Jt.localVar(Jt.valueType("i32"),Jt.identifier("current_env_addr"))),this._instructions=[...Ai(),...this._instructions])}useMatcher(){this._enabledMatcher||(this._enabledMatcher=!0,this._dependencies.push(zi))}useComparator(e){this._enableComparator=!0,this._includingComparisonOperators=[...new Set([...this._includingComparisonOperators,e])]}}const ts=(e,n)=>({...n,body:[...n.body,...e.body]});class rs{_name;_code;_dependencies;_link;additionalFields=[];constructor(e){this._name=e.name,this._code=e.code,this._dependencies=(e.dependencies??[]).slice(),this._link=e.link}get name(){return this._name}get code(){return this._code}get dependencies(){return this._dependencies}addDependency(e){return this._dependencies.push(e),this}addDependencies(e){return e.forEach((e=>this.addDependency(e))),this}get link(){return this._link}addField(e){return this.additionalFields.push(e),this}addFields(e){return e.forEach((e=>this.addField(e))),this}build(){const e=[],n=t=>{e.push(t),t.dependencies&&t.dependencies.forEach(n)};n(this);const t=[];for(;;){const n=e.pop();if(!n)break;t.find((e=>e.name===n.name))||t.push(n)}return t.reverse().slice().reduce(((e,n)=>{return ee(e,(t=n.code,ci(new rr(t))))(((e,t)=>te((n.link??ts)(e,t))));var t}),te(Jt.mod([]))).map((e=>({...e,body:[...e.body,...this.additionalFields]})))}}const is={LessThan:"lt",LessEqualThan:"le",GreaterThan:"gt",GreaterEqualThan:"ge",Equal:"eq",NotEqual:"ne"},ss={FAdd:"add",FSub:"sub",FMultiply:"mul",FDiv:"div"},as=Q({wildcardPattern:()=>te(fi`
        ${Pi}
        local.get $value
        ${Oi}
      `()),idPattern:()=>te(fi`
        ${Pi}
        local.get $value
        ${Ri}
      `()),emptyListPattern:()=>te(fi`
        ${Pi}
        local.get $value
        ${Wi}
      `()),listConsPattern:(e,n,t)=>ee(t(e.head,n),t(e.tail,n))(((e,n)=>te(fi`
          local.get $value
          if (result i32)
            local.get $value
            local.get $value
            ${Ni}
            local.set $value
            ${()=>e}
            ${qi}
            ${ji}
            local.set $value
            ${()=>n}
          else
            i32.const 0
          end
        `())))}),os=Q({emptyListPattern:(e,n)=>n,wildcardPattern:(e,n)=>n,idPattern:({identifier:e},n)=>Ui(e,n),listConsPattern:({head:e,tail:n},t,r)=>r(n,r(e,t))});function ls(e){return e.useEnvironment(),e.useTuple(),e=>fi`
      ;; Note
      ;; Function closure is represented as a tuple:
      ;;   (recursive_flag, env_address, function_index_of_table_elements)
      ${Pi}
      i32.const ${e}
      ${Ti}

      ;; Note:
      ;; We should add the following tag to LSB 4-bits of the closure address.
      ;; [1110] = 0xd
      i32.const 4
      i32.shl
      i32.const 14
      i32.or
    `()}const cs=fi`
  i32.const 4
  i32.shr_u
  ${()=>wi(0)} ;; env for the closure is stored as the 1st value
`,us=fi`
  i32.const 4
  i32.shr_u
  ${()=>wi(1)} ;; function body index for the closure is stored as the 2nd value
`,ds=()=>e=>{const n=e=>{const t=tr(e,n);return"Func"===t.kind?{...t,instructions:vi(t.instructions)}:"IfInstruction"===t.kind?{...t,thenExpr:vi(t.thenExpr),elseExpr:vi(t.elseExpr)}:t};return n(e)},ps=()=>e=>{const n=e=>{const t=tr(e,n);if("Func"===t.kind){let e=t.instructions;for(;;){const n=Bi(e);if(!(n.length<e.length))break;e=n}return{...t,instructions:e}}return t};return n(e)},fs=e=>e;const ms=Q({boolLiteral:({value:e})=>te([Jt.int32NumericInstr("i32.const",[Jt.int32(e?1:0)])]),emptyList:(e,n)=>(n.useList(),te(Fi())),intLiteral:({value:e})=>te([Jt.int32NumericInstr("i32.const",[Jt.int32(j(e))])]),floatLiteral:({value:e},n)=>(n.useFloat(),te((e=>fi`
    ${()=>Jt.float64NumericInstr("f64.const",[Jt.float64(e)])}
    call $__float_new__
  `())(e))),unaryExpression:(e,n,t)=>{if("Minus"===e.op.kind)return t(e.exp,n).map((e=>fi`
        ${()=>e}
        i32.const -1
        i32.mul
        i32.const 2
        i32.add
      `()));if("FMinus"===e.op.kind)return n.useFloat(),t(e.exp,n).map((e=>fi`
        ${()=>e}
        ${bi}
        f64.const -1
        f64.mul
        ${ki}
      `()));throw new Error(`invalid operation kind: ${e.op.kind}`)},binaryExpression:(e,n,t)=>ee(t(e.left,n),t(e.right,n))(((t,r)=>{switch(e.op.kind){case"Add":return te(fi`
            ${()=>t}
            ${()=>r}
            i32.add
            i32.const 1
            i32.sub
          `());case"Sub":return te(fi`
            ${()=>t}
            ${()=>r}
            i32.sub
            i32.const 1
            i32.add
          `());case"Multiply":return te(fi`
            ${()=>t}
            i32.const 1
            i32.sub
            ${()=>r}
            i32.const 1
            i32.shr_s
            i32.mul
            i32.const 1
            i32.add
          `());case"Div":return te(fi`
          ${()=>t}
          i32.const 1
          i32.shr_s
          
          ${()=>r}
          i32.const 1
          i32.shr_s

          i32.div_s
          i32.const 1
          i32.shl
          i32.const 1
          i32.or
        `());case"Or":return te([...t,...r,Jt.int32NumericInstr("i32.or",[])]);case"And":return te([...t,...r,Jt.int32NumericInstr("i32.and",[])]);case"LessThan":case"LessEqualThan":case"GreaterThan":case"GreaterEqualThan":case"Equal":case"NotEqual":{const{typeValueMap:i,dispatchUsingInferredType:s}=n.getOptions(),a=e.left._nodeId?i.get(e.left._nodeId):void 0,o=e.right._nodeId?i.get(e.right._nodeId):void 0,l=!!s&&("Bool"===a?.kind||"Int"===a?.kind||"Bool"===o?.kind||"Int"===o?.kind),c=!!s&&("Float"===a?.kind||"Float"===o?.kind),u=is[e.op.kind];return l?te([...t,...r,...Yi(u)]):c?(n.useFloat(),te([...t,...bi(),...r,...bi(),...es(u)])):(n.useComparator(u),te([...t,...r,...Ji(u)]))}case"PEqual":return te([...t,...r,Jt.int32NumericInstr("i32.eq",[])]);case"PNotEqual":return te([...t,...r,Jt.int32NumericInstr("i32.ne",[])]);case"FAdd":case"FSub":case"FMultiply":case"FDiv":return n.useFloat(),te(fi`
            ${()=>t}
            ${bi}
            ${()=>r}
            ${bi}
            f64.${ss[e.op.kind]}
            ${ki}
          `());default:return re({message:`invalid kind: ${e.op.kind}`})}})).error((n=>({...n,occurence:e}))),listConstructor:(e,n,t)=>(n.useList(),ee(t(e.head,n),t(e.tail,n))(((e,n)=>te([...n,...e,...Li()])))),ifExpression:(e,n,t)=>ee(t(e.cond,n),t(e.then,n),t(e.else,n))(((e,n,t)=>te(fi`
        ${()=>e}
        if (result i32)
          ${()=>n}
        else
          ${()=>t}
        end
      `()))),matchExpression:(e,n,t)=>{n.useEnvironment(),n.useMatcher(),n.useLocalVar(mi`(local $value_for_matcher i32)`()),n.useLocalVar(mi`(local $matched_env_addr i32)`()),n.useLocalVar(mi`(local $prev_env_addr i32)`());const r=n.getEnv(),i=e=>{const s=(e,i)=>ee((n.matcherDefStack.enter(),as(e.pattern,n).map((e=>[Jt.controlInstr("call",[n.matcherDefStack.leave(e)])]))),(()=>{const i=os(e.pattern,r);return n.setEnv(i),t(e.exp,n).tap((()=>n.setEnv(r)))})())(((e,n)=>te(fi`
            ${Pi}
            local.get $value_for_matcher
            ${()=>e}
            local.tee $matched_env_addr
            if (result i32)
              ${Pi}
              local.set $prev_env_addr
              local.get $matched_env_addr
              ${qi}
              ${()=>n}
              local.get $prev_env_addr
              ${qi}
            else
              ${()=>i}
            end
          `())));return"PatternMatchClause"===e.kind?s(e,fi`
          unreachable
        `()):i(e.or).mapValue((n=>s(e.patternMatch,n)))};return ee(t(e.exp,n),i(e.matchClause))(((e,n)=>te(fi`
          ${()=>e}
          local.set $value_for_matcher
          ${()=>n}
        `())))},identifier:(e,n)=>(n.useEnvironment(),n.getEnv().getIndex(e).map((e=>(e=>fi`
    local.get $current_env_addr
    i32.const ${e}
    call $__env_get__
  `())(e))).error((n=>({...n,occurence:e})))),functionDefinition:(e,n,t)=>{n.funcDefStack.enter();const r=n.getEnv(),i=Ui({kind:"Identifier",name:"__anonymous__"},r),s=Ui(e.param,i);return n.setEnv(s),t(e.body,n).map((e=>ls(n)(n.funcDefStack.leave(e)))).tap((()=>n.setEnv(r)))},functionApplication:(e,n,t)=>(n.useEnvironment(),n.useLocalVar(mi`(local $closure_addr i32)`()),n.useLocalVar(mi`(local $prev_closure_addr i32)`()),ee(t(e.argument,n),t(e.callee,n))(((e,t)=>te(fi`
        local.get $closure_addr
        local.set $prev_closure_addr
        ${()=>t}
        local.tee $closure_addr
        ${cs}

        ;; Note
        ;; bind the closure's own address for recursive call
        local.get $closure_addr
        ${Vi}

        ${()=>e}
        ${Vi}

        local.get $closure_addr
        ${us}
        ${n.funcDefStack.callInstr}
        local.get $prev_closure_addr
        local.set $closure_addr
      `())))),letExpression:(e,n,t)=>{n.useEnvironment();const r=n.getEnv();return ne([t(e.binding,n),(()=>{const i=Ui(e.identifier,r);return n.setEnv(i),t(e.exp,n).tap((()=>n.setEnv(r))).map((e=>[...Ki(),...e]))})()]).map((e=>[...Pi(),...e.flat(),...Di()]))},letRecExpression:(e,n,t)=>{n.useEnvironment(),n.funcDefStack.enter();const r=n.getEnv(),i=Ui(e.identifier,r);return n.setEnv(i),ne([(()=>{const r=Ui(e.binding.param,i);return n.setEnv(r),t(e.binding.body,n).map((e=>ls(n)(n.funcDefStack.leave(e)))).tap((()=>n.setEnv(i)))})(),(n.setEnv(i),t(e.exp,n).map((e=>[...Ki(),...e])))]).map((e=>[...Pi(),...e.flat(),...Di()])).tap((()=>n.setEnv(r)))}});class hs{buffer=[];level=0;append(e){const n=this.buffer.pop();return n?(n.endsWith("(")||!n.trim().length?this.buffer.push(n+e):this.buffer.push(n+" "+e),this):(this.pushLine(e),this)}lp(){const e=this.buffer.pop();return e?(e.trim().length?this.buffer.push(e+" ("):this.buffer.push(e+"("),this):(this.pushLine("("),this)}keywordToken(e){return this.append(e)}memArg(e,n){return this.append(`${e}${n}`)}rp(){const e=this.buffer.pop();return e?(this.buffer.push(e+")"),this):(this.pushLine(")"),this)}pushLine(e=""){return this.buffer.push("".padStart(2*this.level," ")+e.trim()),this}dump(){return this.buffer.join("\n")}indent(){this.level+=1}unindent(){this.level-=1}}function _s(e,n){n.append(`${e.value}`)}function gs(e,n){e&&n.append("$"+e.value)}function ys(e,n){n.append(e.valueKind)}function ks(e,n){n.lp().keywordToken("param"),gs(e.id,n),ys(e.valueType,n),n.rp()}function bs(e,n){n.lp().keywordToken("result"),ys(e,n),n.rp()}function vs(e,n){"Identifier"===e.kind?gs(e,n):_s(e,n)}function $s(e,n){n.indent(),e.forEach((e=>{switch(n.pushLine(),e.kind){case"IfInstruction":return function(e,n){n.keywordToken("if"),function(e,n){e.type&&(n.lp().keywordToken("type"),vs(e.type,n),n.rp()),e.results.forEach((e=>bs(e,n)))}(e.blockType,n),$s(e.thenExpr,n),n.pushLine().keywordToken("else"),$s(e.elseExpr,n),n.pushLine().keywordToken("end")}(e,n);case"Int32NumericInstruction":case"Int64NumericInstruction":case"Float32NumericInstruction":case"Float64NumericInstruction":return function(e,n){n.keywordToken(e.instructionKind),e.parameters.forEach((e=>_s(e,n)))}(e,n);case"ControlInstruction":return function(e,n){n.keywordToken(e.instructionKind),e.parameters.forEach((e=>{"FuncTypeRef"===e.kind?function(e,n){n.lp().keywordToken("type"),vs(e.type,n),n.rp()}(e,n):vs(e,n)}))}(e,n);case"MemoryInstruction":return function(e,n){n.keywordToken(e.instructionKind),e.offset&&n.memArg("offset=",e.offset.value),e.align&&n.memArg("align=",e.align.value)}(e,n);case"VariableInstruction":return function(e,n){n.keywordToken(e.instructionKind),e.parameters.forEach((e=>vs(e,n)))}(e,n)}})),n.unindent()}function xs(e,n){_s(e.min,n),e.max&&_s(e.max,n)}function Ts(e,n){switch(e.kind){case"Type":return function(e,n){n.pushLine().lp().keywordToken("type"),gs(e.id,n),function(e,n){n.lp().keywordToken("func"),e.params.forEach((e=>ks(e,n))),e.results.forEach((e=>bs(e,n))),n.rp()}(e.funcType,n),n.rp()}(e,n);case"Func":return function(e,n){n.pushLine().lp().keywordToken("func"),gs(e.id,n),function(e,n){e.type&&(n.lp().keywordToken("type"),vs(e.type,n),n.rp()),e.params.forEach((e=>ks(e,n))),e.results.forEach((e=>bs(e,n)))}(e.signature,n),e.locals.forEach((e=>function(e,n){n.lp().keywordToken("local"),gs(e.id,n),ys(e.valueType,n),n.rp()}(e,n))),$s(e.instructions,n),n.rp()}(e,n);case"Table":return function(e,n){n.pushLine().lp().keywordToken("table"),gs(e.id,n),e.tableType&&function(e,n){xs(e.limits,n),function(e,n){"Funcref"===e.refKind?n.keywordToken("funcref"):n.keywordToken("externref")}(e.refType,n)}(e.tableType,n),e.elemList&&(n.keywordToken("funcref"),function(e,n){n.lp().keywordToken("elem"),e.indices.forEach((e=>vs(e,n))),n.rp()}(e.elemList,n)),n.rp()}(e,n);case"Memory":return function(e,n){n.pushLine().lp().keywordToken("memory"),gs(e.id,n),xs(e.limits,n),n.rp()}(e,n);case"Global":return function(e,n){n.pushLine().lp().keywordToken("global"),gs(e.id,n),function(e,n){"MutValueType"===e.kind?(n.lp().keywordToken("mut"),ys(e.valueType,n),n.rp()):ys(e,n)}(e.type,n),$s(e.expr,n),n.rp()}(e,n);case"Export":return function(e,n){n.pushLine().lp().keywordToken("export"),function(e,n){const t=e.replace(/"/g,'\\"').replace(/\t/g,"\\\t").replace(/\n/g,"\\\n").replace(/\r/g,"\\\r").replace(/\\/g,"\\\\");n.append(`"${t}"`)}(e.name,n),function(e,n){switch(e.kind){case"ExportedFunc":n.lp().keywordToken("func");break;case"ExportedGlobal":n.lp().keywordToken("global");break;case"ExportedMemory":n.lp().keywordToken("memory");break;case"ExportedTable":n.lp().keywordToken("table");break;default:throw new Error(`invalid kind: ${e.kind}`)}vs(e.index,n),n.rp()}(e.sec,n),n.rp()}(e,n);case"Elem":return function(e,n){n.pushLine().lp().keywordToken("elem"),gs(e.id,n),n.indent(),n.pushLine().lp().keywordToken("offset"),$s(e.offsetExpr,n),n.rp(),n.pushLine(),function(e,n){n.keywordToken("func"),e.indices.forEach((e=>vs(e,n)))}(e.elemList,n),n.unindent(),n.rp()}(e,n);default:throw new Error(`unknow kind: ${e.kind}`)}}function ws(e){const n=new hs;return function(e,n){n.pushLine().lp().keywordToken("module"),n.indent(),e.body.forEach((e=>Ts(e,n))),n.unindent(),n.rp()}(e,n),n.dump()}function Es(e,n){if("Int"===n.kind)return e=>({...n,value:M(0,e)});if("Float"===n.kind)return t=>({...n,value:C(e,t)});if("Bool"===n.kind)return e=>({...n,value:S(0,e)});if("List"===n.kind){const t=Es(e,n.elementType);return r=>({...n,value:A(e,r).map(t)})}if("TypeParameter"===n.kind)return()=>({...n,value:"unknown"});if("Function"===n.kind)return e=>({...n,value:`Closure@${K(e,4)}`});throw new Error(`${n.kind}`)}const Is=function(e={}){const n=e.remapWithSubstitutions&&P(e.remapWithSubstitutions.map((e=>e.from))),t=n&&n.reduce(((e,n)=>(e[n.id]=!0,e)),[]),r={idMap(e){return t?(t[e]=void 0,e-t.slice(this.baseId,e).reduce(((e,n)=>n?e+1:e),0)-this.baseId):e-this.baseId},baseId:0};return e=>{const n=Z(e);return H(e,{...r,baseId:n})}}(),{forEachChild:Fs,visitEachChild:Ls}=J(["argument","binding","body","callee","cond","else","exp","head","identifier","left","matchClause","or","param","pattern","patternMatch","right","tail","then"]);function Ns({code$:e,settingsService:n}){const t=new T.B,r=new T.B,i=e.asObservable().pipe((0,x.B)(100),(0,E.T)(Oe),(0,I.u)()),s=new T.B,a=(0,w.z)(s,e,i).pipe((0,x.B)(50),(0,E.T)((([e,n,t])=>t.map((t=>{const r=We(n,e.start),i=We(n,e.end);let s=null;const a=[],o=e=>{(e.loc?.pos??Number.MAX_SAFE_INTEGER)<=r&&i<=(e.loc?.end??-1)&&(s=e,a.push(e._nodeId)),Fs(e,o)};return o(t),{path:a,found:s}})))),(0,I.u)()),o=i.pipe((0,E.T)((e=>e.error((e=>({...e,messageWithTypes:void 0}))).mapValue(Tn))),(0,I.u)()),l=o.pipe((0,E.T)((e=>e.map((e=>e.typeValueMap))))),c=o.pipe((0,E.T)((e=>e.map((e=>e.rootPrimaryType.expressionType))))),u=(0,w.z)(i,l).pipe((0,E.T)((([e,n])=>{return t=n,e.map((e=>{if(!t.ok)return e;const n=t.value,r=e=>{const t=Ls(e,r);if(!e._nodeId)return t;const i=n.get(e._nodeId);return i?{typeInfo:Is(i),...t}:t};return r(e)}));var t})),(0,I.u)()),d=(0,w.z)(i,l,n.settings$).pipe((0,E.T)((([e,n,{dispatchUsingInferredType:t,reduceInstructions:r}])=>ee(e,n)(((e,n)=>function(e,n={dispatchUsingInferredType:!1,reduceInstructions:!1,typeValueMap:new Map}){const t=new ns(n);return ms(e,t).mapValue((e=>{const r=Jt.func(Jt.funcSig([],[Jt.valueType("i32")]),t.getLocalsMainFn(),[...t.getInstructions(),...e],Jt.identifier("main")),i=Jt.exportNode("main",Jt.exportedFunc(Jt.identifier("main")));return new rs({name:"compiled",code:"(module)"}).addDependencies(t.getDependencies()).addFields(t.matcherDefStack.buildFuncs()).addFields(t.funcDefStack.buildFuncs()).addField(r).addFields(t.funcDefStack.buildTables()).addField(i).build().map(function(e){return e.reduceInstructions?function(...e){return e.reduce(((e,n)=>{const t=n();return n=>t(e(n))}),fs)}(ds,ps):fs}(n)).error((e=>({...e,occurence:void 0})))}))}(e,{typeValueMap:n,dispatchUsingInferredType:t,reduceInstructions:r}))))),(0,I.u)()),p=d.pipe((0,E.T)((e=>e.map(ws))),(0,I.u)()),f=(0,w.z)([d,n.settings$]).pipe((0,E.T)((([e,{enableNameSection:n}])=>e.mapValue((e=>Yt(e,{enableNameSection:n})))))),m=(0,w.z)(e,c).pipe((0,E.T)((([e,n])=>{if(n.ok)return[];{const{line:t,character:r}=function(e,n){let t=0,r=0;for(let i=0;i<e.length&&i<n;i++)"\n"===e[i]?(r=0,t++):r++;return{line:t,character:r}}(e,n.value.occurence.loc.pos);return[{type:"error",text:n.value.messageWithTypes?n.value.messageWithTypes(Is):n.value.message,row:t,column:r}]}})),(0,I.u)()),h=r.pipe((0,F.E)((0,w.z)(c,f)),(0,L.n)((async([e,[n,t]])=>{if(e)return{shouldClear:!0};if(!n.ok)return{type:"error",message:n.value.message};if(!t.ok)return{type:"error",message:t.value.message};try{const{instance:e}=await WebAssembly.instantiate(t.value);return{type:"success",value:Es(e,n.value)(e.exports.main())}}catch(e){if(!(e instanceof Error))throw e;return{type:"error",message:e.message||"unknown error"}}})),(0,N.S)(((e,n)=>n.shouldClear?[]:[...e,n]),[]));return{initialContent:e.getValue(),rawCode$:t,code$:e,execute$:r,selection$:s,selectedAstNode$:a,parseResult$:i,typeValueMap$:l,ast$:u,primaryType$:c,diagnostics$:m,wat$:p,wasm$:f,evaluatedResult$:h}}const js={enableNameSection:!0,dispatchUsingInferredType:!0,reduceInstructions:!0},Ms=(0,k.createContext)(null),Cs=Ms.Provider,Ss=(0,k.createContext)(null),As=Ss.Provider;function Vs({code$:e,children:n}){const t=function(){const e=new v.t(js);return{patch:n=>{const t=e.getValue();e.next({...t,...n})},settings$:e.asObservable()}}(),r=Ns({code$:e,settingsService:t});return(0,m.jsx)(Cs,{value:t,children:(0,m.jsx)(As,{value:r,children:n})})}const Ks=Ss,Ps=Ms;var qs=t(3373),Ds=t.n(qs),Bs=t(465);function zs(e){const n=(0,k.useContext)(Ps),[t,r]=(0,k.useState)(js[e]);return(0,k.useEffect)((()=>n.settings$.pipe((0,N.S)(((e,n)=>({prev:e.current,current:n})),{current:js,prev:null}),(0,Bs.p)((n=>!n.prev||n.prev[e]!==n.current[e]))).subscribe((({current:n})=>r(n[e]))).unsubscribe),[]),[t,(0,k.useCallback)((t=>n.patch({[e]:t})),[n])]}const Os=[{name:"Integer arimetic expression",code:"\n(2 + 6) * 4 / 5\n    "},{name:"Floating number arithmetic expression",code:"\n2.0 *. 1.6 +. 3.3\n    "},{name:"If expression",code:"\n1 = 2 then true else false\n    "},{name:"Let expression",code:"\nlet a = 1 in\nlet b = 2 in\nlet a = 4 in\n\na * b + a\n    "},{name:"Function application",code:"\nlet add = fun a -> fun b -> a + b in\nadd 10 20\n    "},{name:"Recursive function",code:"\nlet rec fact = fun n ->\n  if n < 2 then 1 else n * fact(n - 1) in\nfact 10\n    "},{name:"List and pattern matching",code:"\nlet rec range = fun s -> fun e ->\n  if s > e - 1 then [] else s::range (s + 1) e in\n\nlet rec map = fun f -> fun l ->\n  match l with [] -> [] | x::y -> (f x)::(map f y) in\n\nlet l1 = range 0 10 in\nlet twice = fun x -> x * 2 in\nmap twice l1\n    "}];function Ws({className:e}){const n=(0,k.useContext)(Ks),[t,r]=zs("dispatchUsingInferredType"),[s,a]=zs("reduceInstructions"),[o,l]=zs("enableNameSection"),[c,u]=(0,k.useState)(!1),[d,p]=(0,k.useState)(!1),f=(0,k.useCallback)((()=>u(!1)),[]),h=(0,k.useCallback)((()=>p(!1)),[]),_=e=>n=>{n?document.addEventListener("click",e,{once:!0}):document.removeEventListener("click",e)};return(0,m.jsxs)("header",{className:Ds()(e,i.default.root),children:[(0,m.jsxs)("div",{className:i.default.main,children:[(0,m.jsx)("h1",{className:i.default.heading,children:"PicoML Playground"}),(0,m.jsxs)("div",{className:Ds()(i.default.buttonWrap,{[i.default.open]:d}),onClick:e=>e.stopPropagation(),children:[(0,m.jsx)("button",{className:i.default.textButton,onClick:()=>p(!d),children:"Examples"}),d&&(0,m.jsx)("div",{className:Ds()(i.default.panel,i.default.left),ref:_(h),children:(0,m.jsx)("ul",{className:i.default.exampleList,children:Os.map((({name:e,code:t})=>(0,m.jsx)("li",{className:i.default.exampleItem,children:(0,m.jsx)("button",{onClick:()=>{n.rawCode$.next(t.trim()),h()},children:e})},e)))})})]})]}),(0,m.jsx)("div",{className:i.default.subActions,children:(0,m.jsxs)("div",{className:Ds()(i.default.buttonWrap,{[i.default.open]:c}),onClick:e=>e.stopPropagation(),children:[(0,m.jsx)("button",{className:i.default.textButton,onClick:()=>u(!c),children:"Settings"}),c&&(0,m.jsxs)("div",{className:Ds()(i.default.panel,i.default.right),ref:_(f),children:[(0,m.jsxs)("div",{className:i.default.settingItem,children:[(0,m.jsxs)("label",{children:[(0,m.jsx)("input",{type:"checkbox",checked:t,onChange:()=>r(!t)}),(0,m.jsx)("span",{children:"Static Dispatch"})]}),(0,m.jsx)("p",{children:"If enabled, compilation of some polymorphic operations will be optimized using inferred type statically."})]}),(0,m.jsxs)("div",{className:i.default.settingItem,children:[(0,m.jsxs)("label",{children:[(0,m.jsx)("input",{type:"checkbox",checked:s,onChange:()=>a(!s)}),(0,m.jsx)("span",{children:"Reduce Instructions"})]}),(0,m.jsx)("p",{children:"If enabled, redundant WASM instructions(e.g. unneeded get/set floating-point values) will be removed."})]}),(0,m.jsxs)("div",{className:i.default.settingItem,children:[(0,m.jsxs)("label",{children:[(0,m.jsx)("input",{type:"checkbox",checked:o,onChange:()=>l(!o)}),(0,m.jsx)("span",{children:"Emit WASM name section"})]}),(0,m.jsx)("p",{children:"If enabled, the names of functions or variables are reflected to Chrome devtool. "})]})]})]})})]})}function Rs({children:e,sectionName:n}){return(0,m.jsxs)("section",{className:s.default.root,children:[n&&(0,m.jsx)("h2",{className:s.default.sectionName,children:n}),(0,m.jsx)("div",{className:s.default.inner,children:e})]})}var Us=t(45);function Gs(){const e=(0,k.useRef)(null),n=(0,k.useContext)(Ks);return(0,k.useEffect)((()=>{if(e.current)return function(e,n){if(!e)return;const t=g().edit(e,{mode:"ace/mode/ocaml"});t.commands.addCommand({name:"executeWasm",bindKey:{win:"Ctrl-Enter",mac:"Command-Enter"},exec:()=>n.execute$.next(null)}),t.setTheme("ace/theme/iceberg");const r=t.getSession();r.setTabSize(2),r.setValue(n.initialContent),t.on("change",(()=>n.code$.next(r.getValue())));const i=new Us.yU;return i.add(n.rawCode$.subscribe((e=>r.setValue(e)))),i.add(n.diagnostics$.subscribe((e=>r.setAnnotations([...e])))),r.selection.on("changeSelection",(()=>{const e=r.selection.getRange();n.selection$.next({start:{line:e.start.row,character:e.start.column},end:{line:e.end.row,character:e.end.column}})})),()=>{t.destroy(),i.unsubscribe()}}(e.current,n)}),[e.current,n]),(0,m.jsx)("div",{className:Ds()(a.default.root),ref:e})}var Hs=t(7641),Zs=t.n(Hs);function Qs(){const[e,n]=(0,k.useState)({__html:""}),[t,r]=(0,k.useState)(!1),i=(0,k.useContext)(Ks);return(0,k.useEffect)((()=>{const e=i.wat$.subscribe((e=>{if(e.ok){r(!1);const t=Zs().highlight(e.value,Zs().languages.wasm,"wasm");n({__html:t})}else console.error(e.value.message),r(!0)}));return()=>e.unsubscribe()}),[]),t?(0,m.jsx)("div",{children:"Error"}):(0,m.jsx)("div",{className:Ds()(o.default.root),children:(0,m.jsx)("pre",{className:"language-wasm",children:(0,m.jsx)("code",{className:"language-wasm",dangerouslySetInnerHTML:e})})})}t(697);var Xs=t(260),Js=t.n(Xs);function Ys(e){return(0,m.jsx)(Js(),{...e,theme:{base00:"#161821",base01:"#1e2132",base02:"#45493e",base03:"#6b7089",base04:"#6b7089",base05:"#c6c8d1",base06:"#c6c8d1",base07:"#c6c8d1",base08:"#ceb0b6",base09:"#89b8c2",base0A:"#84a0c6",base0B:"#89b8c2",base0C:"#89b8c2",base0D:"#84a0c6",base0E:"#84a0c6",base0F:"#686f9a"}})}function ea(e,n){const t=(0,k.useContext)(Ks),[r,i]=(0,k.useState)(n?te(n):null);return(0,k.useEffect)((()=>{const n=t[e];if("object"!=typeof(r=n)||!r.subscribe)throw new Error(`${e} is not Observable`);var r;const s=n.subscribe((e=>{(function(e){return"object"==typeof e&&"boolean"==typeof e.ok})(e)&&i(e)}));return()=>s.unsubscribe()}),[]),r?r.ok?{ready:!0,data:r.value,error:null}:{ready:!0,data:null,error:r.value}:{ready:!1,data:null,error:null}}function na(){const e=ea("ast$"),n=ea("selectedAstNode$");return e.ready?e.error?(0,m.jsx)("div",{children:"Error"}):(0,m.jsx)("div",{className:Ds()(l.default.root),children:(0,m.jsx)(Ys,{src:e.data,shouldCollapse:e=>{const{_nodeId:t}=e.src;return n.data&&n.data.found?!n.data.path.includes(t):e.namespace.length>=3},enableClipboard:!1})}):null}function ta(e){return e<32||e>=127?".":String.fromCharCode(e)}function ra(){const e=ea("wasm$",new Uint8Array);if(!e.ready)return null;if(e.error)return(0,m.jsx)("div",{children:"Error"});const n=function(e){const n=[];let t;for(let r=0;r<e.byteLength;r+=2)r%16==0&&(t={address:K(r,8),values:[],ascii:""},n.push(t)),t.ascii+=ta(e[r]),r+1<e.byteLength?(t.ascii+=ta(e[r+1]),t.values.push(K(e[r],2)+K(e[r+1],2))):t.values.push(K(e[r],2));if(n.length){const e=n[n.length-1];e.values=[...e.values,...[...new Array(8-e.values.length)].map((()=>""))]}return n}(e.data);return(0,m.jsx)("div",{className:Ds()(c.default.root),children:(0,m.jsx)("table",{className:Ds()(c.default.table),children:(0,m.jsx)("tbody",{children:n.map((e=>(0,m.jsxs)("tr",{children:[(0,m.jsx)("th",{className:c.default.addressCell,children:e.address}),e.values.map(((e,n)=>(0,m.jsx)("td",{className:c.default.cell,children:e},n))),(0,m.jsx)("td",{className:c.default.asciiCell,children:e.ascii})]},e.address)))})})})}const ia=(0,k.forwardRef)((function({label:e,children:n,className:t,...r},i){return(0,m.jsx)("button",{...r,className:Ds()(t,d.default.root),"aria-label":e,ref:i,children:n})}));function sa(){return(0,m.jsxs)("svg",{className:p.default.icon,xmlns:"http://www.w3.org/2000/svg",width:"24",height:"24",children:[(0,m.jsx)("path",{fill:"none",d:"M0 0h24v24H0z"}),(0,m.jsx)("path",{d:"M8 5v14l11-7z"})]})}function aa(){return(0,m.jsxs)("svg",{className:p.default.icon,xmlns:"http://www.w3.org/2000/svg",width:"24",height:"24",children:[(0,m.jsx)("path",{fill:"none",d:"M0 0h24v24H0z"}),(0,m.jsx)("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8 0-1.85.63-3.55 1.69-4.9L16.9 18.31A7.902 7.902 0 0112 20zm6.31-3.1L7.1 5.69A7.902 7.902 0 0112 4c4.42 0 8 3.58 8 8 0 1.85-.63 3.55-1.69 4.9z"})]})}const oa=new Intl.NumberFormat(void 0,{useGrouping:!1,minimumFractionDigits:1});function la({node:e}){return"Int"===e.kind?(0,m.jsx)("span",{className:u.default.intNode,children:`${e.value}`}):"Float"===e.kind?(0,m.jsx)("span",{className:u.default.intNode,children:`${oa.format(e.value)}`}):"Bool"===e.kind?(0,m.jsx)("span",{className:u.default.boolNode,children:`${e.value}`}):"List"===e.kind?(0,m.jsxs)(m.Fragment,{children:[(0,m.jsx)("span",{className:u.default.lpToken,children:"["}),e.value.map(((n,t)=>(0,m.jsxs)(k.Fragment,{children:[k.createElement(la,{node:n}),t!==e.value.length-1?(0,m.jsx)("span",{className:u.default.commaToken,children:", "}):null]},t))),(0,m.jsx)("span",{className:u.default.rpToken,children:"]"})]}):"Function"===e.kind?(0,m.jsx)("span",{className:u.default.functionNode,children:`${e.value}`}):null}function ca(){const e=(0,k.useRef)(null),[n,t]=(0,k.useState)([]),r=(0,k.useContext)(Ks);return(0,k.useEffect)((()=>r.evaluatedResult$.subscribe((n=>{t(n),e.current?.scrollIntoView()})).unsubscribe),[]),(0,m.jsxs)("div",{className:u.default.root,children:[(0,m.jsxs)("div",{className:u.default.buttonsArea,children:[(0,m.jsx)(ia,{label:"Evaluate expression",title:"Evaluate expression",onClick:()=>r.execute$.next(null),children:(0,m.jsx)(sa,{})}),(0,m.jsx)(ia,{label:"Clear logs",title:"Clear logs",onClick:()=>r.execute$.next(!0),children:(0,m.jsx)(aa,{})})]}),(0,m.jsx)("ul",{className:u.default.logList,children:n.map(((e,n)=>(0,m.jsxs)("li",{className:u.default.logItem,children:[(0,m.jsxs)("span",{className:u.default.logHeader,children:["result#",n+1]}),(0,m.jsx)("span",{className:Ds()(u.default.logBody,{[u.default.error]:"error"===e.type}),children:"error"===e.type?(0,m.jsxs)(m.Fragment,{children:[(0,m.jsx)("span",{children:"Error: "}),(0,m.jsx)("span",{children:e.message})]}):(0,m.jsx)(la,{node:e.value})})]},n)))}),(0,m.jsx)("span",{ref:e})]})}function ua(e){return(0,m.jsx)(y.A,{...e})}const da=document.getElementById("app");(0,h.render)((0,m.jsx)((function(){const e=function(e){const n=(0,k.useRef)(new v.t(function(e){if(location.hash.startsWith("#code=")){const e=location.hash.slice(6);return(0,b.decompressFromEncodedURIComponent)(e)}return e.trim()}(e)));return(0,k.useEffect)((()=>n.current.pipe((0,$.i)(1),(0,x.B)(100)).subscribe((e=>function(e){const n=new URL(location.href);n.hash=e,location.replace(n.toString())}(`code=${(0,b.compressToEncodedURIComponent)(e)}`))).unsubscribe),[n.current]),n.current}("\n(*                                                                  *)\n(*                 Welcome to PicoML Playground!                    *)\n(*                                                                  *)\n(* Type the folloing to compile and execute the ML expression:      *)\n(* - win: Ctrl + Enter                                              *)\n(* - mac: Command + Enter                                           *)\n\nif true then 1 + 2 * 3 else 0\n");return(0,m.jsxs)(Vs,{code$:e,children:[(0,m.jsx)(Ws,{className:f.default.header}),(0,m.jsx)("main",{className:f.default.main,children:(0,m.jsxs)(ua,{resizerClassName:f.default.resizer,split:"vertical",defaultSize:"43%",children:[(0,m.jsxs)(ua,{resizerClassName:f.default.resizer,split:"horizontal",defaultSize:"65%",children:[(0,m.jsx)(Rs,{children:(0,m.jsx)(Gs,{})}),(0,m.jsx)(Rs,{sectionName:"Evaluation Log",children:(0,m.jsx)(ca,{})})]}),(0,m.jsxs)(ua,{resizerClassName:f.default.resizer,split:"horizontal",defaultSize:"45%",children:[(0,m.jsx)(Rs,{sectionName:"Expression AST",children:(0,m.jsx)(na,{})}),(0,m.jsxs)(ua,{resizerClassName:f.default.resizer,split:"horizontal",defaultSize:"63%",children:[(0,m.jsx)(Rs,{sectionName:"Compiled WAT",children:(0,m.jsx)(Qs,{})}),(0,m.jsx)(Rs,{sectionName:"Compiled WASM",children:(0,m.jsx)(ra,{})})]})]})]})}),(0,m.jsxs)("footer",{className:f.default.footer,children:["Powered by ",(0,m.jsx)("a",{href:"https://github.com/Quramy/pico-ml",children:"https://github.com/Quramy/pico-ml"})]})]})}),{}),da)}},t={};function r(e){var i=t[e];if(void 0!==i)return i.exports;var s=t[e]={id:e,loaded:!1,exports:{}};return n[e].call(s.exports,s,s.exports,r),s.loaded=!0,s.exports}r.m=n,r.amdD=function(){throw new Error("define cannot be used indirect")},e=[],r.O=(n,t,i,s)=>{if(!t){var a=1/0;for(u=0;u<e.length;u++){for(var[t,i,s]=e[u],o=!0,l=0;l<t.length;l++)(!1&s||a>=s)&&Object.keys(r.O).every((e=>r.O[e](t[l])))?t.splice(l--,1):(o=!1,s<a&&(a=s));if(o){e.splice(u--,1);var c=i();void 0!==c&&(n=c)}}return n}s=s||0;for(var u=e.length;u>0&&e[u-1][2]>s;u--)e[u]=e[u-1];e[u]=[t,i,s]},r.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return r.d(n,{a:n}),n},r.d=(e,n)=>{for(var t in n)r.o(n,t)&&!r.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},r.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),r.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),(()=>{var e;r.g.importScripts&&(e=r.g.location+"");var n=r.g.document;if(!e&&n&&(n.currentScript&&(e=n.currentScript.src),!e)){var t=n.getElementsByTagName("script");if(t.length)for(var i=t.length-1;i>-1&&(!e||!/^http(s?):/.test(e));)e=t[i--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),r.p=e})(),(()=>{var e={792:0};r.O.j=n=>0===e[n];var n=(n,t)=>{var i,s,[a,o,l]=t,c=0;if(a.some((n=>0!==e[n]))){for(i in o)r.o(o,i)&&(r.m[i]=o[i]);if(l)var u=l(r)}for(n&&n(t);c<a.length;c++)s=a[c],r.o(e,s)&&e[s]&&e[s][0](),e[s]=0;return r.O(u)},t=self.webpackChunk_pico_ml_playground=self.webpackChunk_pico_ml_playground||[];t.forEach(n.bind(null,0)),t.push=n.bind(null,t.push.bind(t))})();var i=r.O(void 0,[153],(()=>r(4147)));i=r.O(i)})();